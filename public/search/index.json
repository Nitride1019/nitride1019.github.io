[{"content":"題目\r連結: Problem - 1178H - Codeforces 難度: 3500 前置知識: 二分搜尋、最小費用最大流 題解\r本題解主要參考自CF1178H Stock Exchange - ✡smy✡ - 博客园 (cnblogs.com)\n這題等價於尋找一個$[1,n]$和$[n+1,2n]$之間的二分圖匹配，但是匹配的邊會隨著$t$的變化而改變。\n注意到如果一組合法的方案在$t$時刻結束，那麼一定存在一種交換次數不劣於當前方案的方案，使得所有交換都發生在時刻$0$或時刻$t$。\n證明: 考慮一組匹配$i\\to j$\n如果在時刻$0$或時刻$t$，$i$的價格$\\geq$$j$的價格，就可以使用一次交換解決。 否則我們需要在中途換成其他元素，這個元素一定滿足其在時刻$0$的價格$\\leq$$i$的價格，且在時刻$t$的價格$\\geq$$j$的價格。 考慮第一個問題，我們先二分搜尋結束的時間$t$，並進行二分圖匹配確認時間$t$是否合法。\n把所有元素按照時刻$0$的價格由小到大排序，然後$[1,n]$的元素使用貪婪法，選擇在時刻$0$價格不超過它且時刻$t$價格最大的股票。接著開始將所有元素按照時刻$t$的價格由小到大排序，並將$[1,n]$一一對應$[n + 1, 2n]$，若其中一個失配則代表此次二分的時間$t$不合法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool check(int t) { for (int i = 1; i \u0026lt;= 2 * n; i++) ord1[i] = ord2[i] = i; sort(ord1 + 1, ord1 + 2 * n + 1, [\u0026amp;](int x, int y) { if (b[x] == b[y]) return k[x] \u0026gt; k[y]; return b[x] \u0026lt; b[y]; }); ll maxy = 0; for (int i = 1; i \u0026lt;= 2 * n; i++) { maxy = max(maxy, k[ord1[i]] * t + b[ord1[i]]); if (ord1[i] \u0026lt;= n) pos[ord1[i]] = maxy; } sort(pos + 1, pos + 1 + n); sort(ord2 + n + 1, ord2 + 2 * n + 1, [\u0026amp;](int x, int y) { return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); for (int i = 1; i \u0026lt;= n; i++) { if (pos[i] \u0026lt; k[ord2[i + n]] * t + b[ord2[i + n]]) return 0; } return 1; } 考慮第二個問題，我們使用最小費用最大流，並連結以下的邊:\n由源點向$[1,n]$連一條容量為$1$，費用為$0$的邊； 由$[n+1,2n]$向匯點連一條容量為$1$，費用為$0$的邊。 如果$i$可以在時刻$0$換成$j$，就在左邊連$i\\to j$，費用為$1$的邊； 如果$i$可以在時刻$t$換成$j$，就在右邊連$i\\to j$，費用為$1$的的邊。 但是，這題的空間限制不允許我們這麼做。注意到若存在邊$i\\to j$，則代表$i$在該時刻的價格$\\geq j$的價格。因此我們可以按照價格由小往大掃，並將所有點向其前面的點連邊即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void solve(int t) { S = ++tim; T = ++tim; for (int i = 1; i \u0026lt;= 2 * n; i++) { in[i] = ++tim; out[i] = ++tim; if (i \u0026lt;= n) add(S, in[i], 1, 0); else add(out[i], T, 1, 0); add(in[i], out[i], inf, 0); } sum[1] = in[ord1[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], in[ord1[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(in[ord1[i]], sum[i - 1], inf, 1); for (int i = 1; i \u0026lt;= 2 * n; i++) ord2[i] = i; sort(ord2 + 1, ord2 + 1 + 2 * n, [\u0026amp;](int x, int y) { if (k[x] * t + b[x] == k[y] * t + b[y]) return x \u0026gt; y; return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); sum[1] = out[ord2[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], out[ord2[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(out[ord2[i]], sum[i - 1], inf, 1); mcmf(); } 完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 100005, inf = 0x3f3f3f3f; int n, S, T, tim, cnt, res; int in[maxn], out[maxn], id[maxn], head[maxn], dis[maxn], last[maxn], from[maxn]; int ord1[maxn], ord2[maxn], sum[maxn]; queue\u0026lt;int\u0026gt; q; ll k[maxn], b[maxn], pos[maxn]; bool vis[maxn]; struct Edge { int nxt, to, w, c; } edge[2 * maxn]; void add(int x, int y, int w, int c) { edge[++cnt] = {head[x], y, w, c}; head[x] = cnt; edge[++cnt] = {head[y], x, 0, -c}; head[y] = cnt; } bool spfa() { memset(dis, inf, sizeof(int) * (tim + 1)); dis[S] = 0; q.push(S); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = edge[i].nxt) { int to = edge[i].to; if (dis[to] \u0026gt; dis[u] + edge[i].c \u0026amp;\u0026amp; edge[i].w) { dis[to] = dis[u] + edge[i].c; from[to] = u, last[to] = i; if (!vis[to]) { q.push(to); vis[to] = 1; } } } } return dis[T] != inf; } void mcmf() { while (spfa()) { res += dis[T]; int u = T; while (u != S) { edge[last[u]].w--; edge[((last[u] - 1) ^ 1) + 1].w++; u = from[u]; } } } bool check(int t) { for (int i = 1; i \u0026lt;= 2 * n; i++) ord1[i] = ord2[i] = i; sort(ord1 + 1, ord1 + 2 * n + 1, [\u0026amp;](int x, int y) { if (b[x] == b[y]) return k[x] \u0026gt; k[y]; return b[x] \u0026lt; b[y]; }); ll maxy = 0; for (int i = 1; i \u0026lt;= 2 * n; i++) { maxy = max(maxy, k[ord1[i]] * t + b[ord1[i]]); if (ord1[i] \u0026lt;= n) pos[ord1[i]] = maxy; } sort(pos + 1, pos + 1 + n); sort(ord2 + n + 1, ord2 + 2 * n + 1, [\u0026amp;](int x, int y) { return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); for (int i = 1; i \u0026lt;= n; i++) { if (pos[i] \u0026lt; k[ord2[i + n]] * t + b[ord2[i + n]]) return 0; } return 1; } void solve(int t) { S = ++tim; T = ++tim; for (int i = 1; i \u0026lt;= 2 * n; i++) { in[i] = ++tim; out[i] = ++tim; if (i \u0026lt;= n) add(S, in[i], 1, 0); else add(out[i], T, 1, 0); add(in[i], out[i], inf, 0); } sum[1] = in[ord1[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], in[ord1[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(in[ord1[i]], sum[i - 1], inf, 1); for (int i = 1; i \u0026lt;= 2 * n; i++) ord2[i] = i; sort(ord2 + 1, ord2 + 1 + 2 * n, [\u0026amp;](int x, int y) { if (k[x] * t + b[x] == k[y] * t + b[y]) return x \u0026gt; y; return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); sum[1] = out[ord2[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], out[ord2[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(out[ord2[i]], sum[i - 1], inf, 1); mcmf(); } int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2 * n; i++) cin \u0026gt;\u0026gt; k[i] \u0026gt;\u0026gt; b[i]; int l = 0, r = inf; while (l + 1 \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } if (l == inf) { cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; return 0; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39; \u0026#39;; solve(l); cout \u0026lt;\u0026lt; res; } ","date":"2024-08-24T00:00:00Z","permalink":"http://localhost:1313/p/cf1178h-stock-exchange-%E9%A1%8C%E8%A7%A3/","title":"CF1178H Stock Exchange 題解"},{"content":"題目\r連結: Problem - 1588F - Codeforces 前置知識: 強連通分量、根號分塊 難度: 3500 題解\r本題解主要參考自CF1588F Jumping Through the Array - 洛谷专栏 (luogu.com.cn)\n考慮將每B個操作分成一塊，共分為$\\frac{q}{B}$塊，且每次在訪問新的塊時都先將先前的計算結果刪除。\n接著，將目前所在的塊中操作2和操作3的目標節點標記，並對所有打上標記的點與「可以到達該點且沒有標記」的點進行縮點。\n最後就可以來考慮各操作:\n對於操作1，分別計算每個強連通分量中有多少的點在$[l,r]$內，乘上該強連通分量的標記後，再加上原區間和。 對於操作2，我們在縮好的點上打標記。 對於操作3，直接暴力交換即可。 時間複雜度為$O\\left( \\frac{m}{B}(n+B+B\\log B) \\right)$。當$B=\\sqrt{ \\frac{n}{\\log n} }$時，複雜度為$O(n\\sqrt{ n\\log n })$。此外，我們可以進行$O(B^2)$的預處理，使時間複雜度進一步達到$O(n\\sqrt{ n })$\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 200005, B = 1000; struct Query { int op, x, y; } q[maxn]; int n, m, p[maxn]; bool vis[maxn]; ll sum[maxn], tag[maxn], a[maxn]; int id[maxn], nxt[maxn], from[maxn]; vector\u0026lt;int\u0026gt; scc[maxn]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i]; from[p[i]] = i; } cin \u0026gt;\u0026gt; m; for (int ql = 1, qr; ql \u0026lt;= m; ql += B) { for (int i = 1; i \u0026lt;= n; i++) sum[i] = sum[i - 1] + a[i]; memset(vis, 0, sizeof vis); memset(tag, 0, sizeof tag); memset(id, 0, sizeof id); for (int i = 1; i \u0026lt;= n; i++) scc[i].clear(); qr = min(m, ql + B - 1); for (int i = 1; i \u0026lt;= qr - ql + 1; i++) { cin \u0026gt;\u0026gt; q[i].op \u0026gt;\u0026gt; q[i].x \u0026gt;\u0026gt; q[i].y; if (q[i].op == 2) vis[q[i].x] = 1; if (q[i].op == 3) vis[q[i].x] = vis[q[i].y] = 1; } int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (vis[i]) { id[i] = ++cnt; int x = from[i]; while (!vis[x]) { id[x] = cnt; x = from[x]; } } } for (int i = 1; i \u0026lt;= n; i++) if (vis[i]) nxt[id[i]] = id[p[i]]; for (int i = 1; i \u0026lt;= n; i++) scc[id[i]].push_back(i); for (int i = 1; i \u0026lt;= qr - ql + 1; i++) { if (q[i].op == 1) { ll res = 0; for (int j = 1; j \u0026lt;= cnt; j++) { res += 1ll * tag[j] * max(0ll, 1ll * (lower_bound(scc[j].begin(), scc[j].end(), q[i].y + 1) - scc[j].begin() - (lower_bound(scc[j].begin(), scc[j].end(), q[i].x) - scc[j].begin()))); } cout \u0026lt;\u0026lt; res + sum[q[i].y] - sum[q[i].x - 1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else if (q[i].op == 2) { int x = id[q[i].x], y = x; do { tag[y] += q[i].y; y = nxt[y]; } while (y \u0026amp;\u0026amp; y != x); } else { swap(nxt[id[q[i].x]], nxt[id[q[i].y]]); swap(from[p[q[i].x]], from[p[q[i].y]]); swap(p[q[i].x], p[q[i].y]); } } for (int i = 1; i \u0026lt;= n; i++) a[i] += tag[id[i]]; } } ","date":"2024-08-14T00:00:00Z","permalink":"http://localhost:1313/p/cf1588f-jumping-through-the-array-%E9%A1%8C%E8%A7%A3/","title":"CF1588F Jumping Through the Array 題解"},{"content":"題目\r連結: Problem - 1876g - Codeforces 前置知識: 帶權並查集 難度: 3500 題解\r本題解主要參考自Guizhou H. - 洛谷专栏 (luogu.com.cn)\n顯然這題可以使用貪婪法。我們對每個問題$(l,r,x)$，先從$r$到$l$掃。若$a_{r}\u0026lt;x$，則該問題的答案相當於$r\\cdot \\left\\lceil \\frac{x-a_{r}}{2} \\right\\rceil$加上$\\left( l,r-1,\\left\\lfloor \\frac{x+a_{r}}{2} \\right\\rfloor \\right)的答案$。\n將$i$從$n$枚舉到$1$，並將每個$r=i$的問題依$x$從大到小放入優先佇列中。若$a_{i}\u0026lt;x$，則該問題的答案加上$i\\cdot \\left\\lceil \\frac{x-a_{r}}{2} \\right\\rceil$接著再將問題$\\left( l,r-1,\\left\\lfloor \\frac{x+a_{r}}{2} \\right\\rfloor \\right)$存起來，等$i$變為$r-1$時再重複以上操作。\n這裡使用帶權並查集維護答案。若當前題目的$x$與上題的相同，則將此題的父節點設為上題，再將此題的權值減去上題當前的權值(因為之後統計答案時，會將上題從葉節點計算到根節點，而我們只需要當前節點至根節點的答案)。\n最後，對$l=i$的問題計算答案即可。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 300005; int p[maxn]; ll d[maxn], res[maxn]; int n, q, a[maxn]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; in[maxn], out[maxn]; int find(int x) { if (p[x] == x) return x; int rt = find(p[x]); if (p[x] != rt) d[x] += d[p[x]]; return p[x] = rt; } void merge(int x, int y) { x = find(x); y = find(y); d[x] -= d[y]; p[x] = y; } int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= q; i++) { int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; in[r].push_back({x, i}); out[l].push_back({x, i}); p[i] = i; } priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pq; for (int i = n; i \u0026gt;= 1; i--) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; tmp; int last_x = 0x3f3f3f3f, last_id = 0; for (auto j : in[i]) pq.push(j); while (!pq.empty() \u0026amp;\u0026amp; pq.top().first \u0026gt; a[i]) { ll x = pq.top().first, id = pq.top().second; pq.pop(); d[id] += ((x - a[i] + 1) / 2) * i; x = (x + a[i]) / 2; if (x == last_x) merge(id, last_id); // 如果x跟上一個x一樣，直接沿用上一題的答案 else { last_x = x; last_id = id; tmp.push_back({x, id}); // 原問題變成 (l, r - 1, (x + a[r]) / 2) } } for (auto j : tmp) pq.push(j); for (auto j : out[i]) { int rt = find(j.second); res[j.second] = (rt == j.second ? d[rt] : d[rt] + d[j.second]); } } for (int i = 1; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2024-08-13T00:00:00Z","permalink":"http://localhost:1313/p/cf1876g-clubstep-%E9%A1%8C%E8%A7%A3/","title":"CF1876G Clubstep 題解"},{"content":"題目\r連結: Problem - 1158F - Codeforces 前置知識: Bitmask DP 難度: 3500 題解\r本題解主要參考自官方題解。\n首先，定義$l_{1},l_{2},\\dots l_{p}$為，在$a[l_{i}+1\\dots l_{i+1}]$中，$[1,c]$中的數字均有出現過，且$a_{l_{i+1}}$恰好出現過一次的下標。稱$a[l_{i}+1\\dots l_{i+1}]$為critical array。\n由此，若求的出$l_{1},l_{2},\\dots l_{p}$，則可得出$a$的密度$\\geq p$。\n注意到由於$l_{i+1}-l_{i}+1\\geq c$，因此長度為$n$的陣列$a$其密度必$\\leq k=\\frac{n}{c}$。\n接著定義$dp[t][i]$為$a[1\\dots i]$中「剛好可以分成$t$個critical array」的子序列的數量。\n此時我們令$f[t]$為$a$中密度$\\geq t$的子序列的數量，得出$f[t]=\\sum^n_{i=1}(dp[t][i]\\cdot 2^{n-i})$，並可藉此求得答案$res[t]=f[t+1]-f[t]$。\n至於要如何求出$dp$，這裡有$2$個方法:\n第$1$個方法可在$O(n^2k)=O\\left( \\frac{n^3}{c} \\right)$的時間內完成。\n令$num[i][j]$為$a[i\\dots j]$中$a_{j}$僅出現過一次的子序列數，$cnt[x][i][j]$為$x$在$a[i\\dots j]$中出現過的次數，則可以得到$num[i][j]=\\Pi_{x=1}^c(2^{cnt[x][i][j]}-1)$，因為$x$在$a[i\\dots j]$共可以產生$2^{cnt[x][i][j]}$種子序列，且至少$x$至少要出現一次，故減去$1$。\n於是就可得到$dp[t][i]$的轉移式: $$dp[t][i]=\\sum_{j=0}^{i-1}(dp[t-1][j]\\cdot num[j+1][i])$$\n第$2$個方法可在$O\\left( nk2^c \\right)=O\\left( \\frac{n^3}{\\log n} \\right)$時間內完成。\n令$u[i][t][mask]$為$a[1\\dots i]$中先選取好$t$個critical array，且在最後一個critical array的結尾到$i$之間已有$mask$的元素被選取的子序列數。\n則可以得到$dp[t][i]=u[i-1][t-1][2^c-i-2^{a_{i}}]$。\n接著我們考慮$u$的轉移式:\n$$u[i][t][mask]=\\begin{cases}u[i-1][t][mask]\u0026amp;\\text{if }a_{i}\\text{ is not in mask}\\newline2u[i-1][t][mask]+u[i-1][t][mask-2^{a_{i}}]\u0026amp;\\text{if }a_{i}\\text{ is in mask}\\end{cases}$$\n由於$u[i][t][mask]$的轉移只會用到$u[i-1]$，故可以節省記憶體空間，使用滾動陣列。\n至於當$mask=0$時，$u[i][t][0]=u[i-1][t][0]+dp[t][i]$，即「加入$a_{i}$前就已經完成$t$個critical array」加上「加入$a_{i}$後剛好完成第$t$個critical array」的子序列數。\n以上便完成了兩種時間複雜的的解法。在$c\u0026gt;\\log_{2}n$時，$\\frac{n^3}{c}\u0026lt; \\frac{n^3}{\\log_{2}n}$，故採用第一種解法；反之則採用第二種解法。如此一來便可通過此題。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 3005; const int mod = 998244353; const ll mod2 = (ll)mod * (ll)mod; void add(int \u0026amp;a, int b) { a += b; if (a \u0026gt;= mod) a -= mod; } int qpow(int a, int b) { int res = 1; while (b) { if (b \u0026amp; 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } int n, c, a[maxn]; int cnt[maxn][maxn]; // cnt[i][x + 1] = i在a[1...x]中出現過的次數 int pw[maxn], inv[maxn]; int k, used_cnt; int dp[maxn][maxn], num[maxn][maxn]; void solve_n2k() { for (int i = 0; i \u0026lt;= n; i++) inv[i] = qpow(pw[i] - 1, mod - 2); for (int i = 0; i \u0026lt; n; i++) { int cur = 1; used_cnt = c; for (int j = i; j \u0026lt; n; j++) { if (cnt[a[j]][i] == cnt[a[j]][j]) used_cnt--; else cur = 1ll * cur * inv[cnt[a[j]][j] - cnt[a[j]][i]] % mod; if (used_cnt != 0) num[i][j] = 0; else num[i][j] = cur; cur = 1ll * cur * (pw[cnt[a[j]][j] - cnt[a[j]][i] + 1] - 1) % mod; } } dp[0][0] = 1; for (int t = 1; t \u0026lt;= k; t++) { for (int i = t * c - 1; i \u0026lt; n; i++) { ll sum = 0; for (int j = i; j \u0026gt;= (t - 1) * c; j--) { sum += 1ll * dp[t - 1][j] * num[j][i]; if (sum \u0026gt;= mod2) sum -= mod2; } dp[t][i + 1] = sum % mod; } } } int u[maxn][1 \u0026lt;\u0026lt; 10]; void solve_nk2powc() { dp[0][0] = 1; u[0][0] = 1; for (int i = 0; i \u0026lt; n; i++) { for (int t = 1; t \u0026lt;= k; t++) dp[t][i + 1] = u[t - 1][((1 \u0026lt;\u0026lt; c) - 1) ^ (1 \u0026lt;\u0026lt; a[i])]; int maxt = min(k - 1, (i / c)); for (int mask = (1 \u0026lt;\u0026lt; c) - 1; mask \u0026gt;= 0; mask--) { if ((mask \u0026gt;\u0026gt; a[i]) \u0026amp; 1) { for (int t = 0; t \u0026lt;= maxt; t++) { add(u[t][mask], u[t][mask]); add(u[t][mask], u[t][mask ^ (1 \u0026lt;\u0026lt; a[i])]); } } } for (int t = 0; t \u0026lt; k; t++) add(u[t][0], dp[t][i + 1]); } } int res[maxn]; bool used[maxn]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i]--; } for (int i = 0; i \u0026lt; c; i++) { cnt[i][0] = 0; for (int x = 0; x \u0026lt; n; x++) { cnt[i][x + 1] = cnt[i][x]; if (a[x] == i) cnt[i][x + 1]++; } } pw[0] = 1; for (int i = 0; i \u0026lt; n; i++) { pw[i + 1] = pw[i] + pw[i]; if (pw[i + 1] \u0026gt;= mod) pw[i + 1] -= mod; } for (int i = 0; i \u0026lt; n; i++) { if (!used[a[i]]) { used[a[i]] = 1; used_cnt++; } if (used_cnt == c) { used_cnt = 0; for (int i = 0; i \u0026lt; c; i++) used[i] = 0; k++; } } if (c \u0026lt;= 10) solve_nk2powc(); else solve_n2k(); for (int i = 0; i \u0026lt;= k; i++) { for (int j = 0; j \u0026lt;= n; j++) { add(res[i], 1ll * dp[i][j] * pw[n - j] % mod); } } for (int i = 0; i \u0026lt; n; i++) { res[i] -= res[i + 1]; if (res[i] \u0026lt; 0) res[i] += mod; } res[0]--; if (res[0] \u0026lt; 0) res[0] += mod; for (int i = 0; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } ","date":"2024-08-10T00:00:00Z","permalink":"http://localhost:1313/p/cf1158f-density-of-subarrays-%E9%A1%8C%E8%A7%A3/","title":"CF1158F Density of Subarrays 題解"},{"content":"前言\r注意!!! 本文是拿來複習用的，所以強烈建議先學過一次再來看。我推薦劉明昌的\u0026laquo;工程數學學習要訣\u0026raquo;上下冊，本文大部分都是從這本書以及一些網路資源上看的。 撰寫本文花了我一個下午。因為我平常沒有做筆記的習慣，所以大家想看的話我再寫別ㄉ。\n一階ODE\r基本定義\r通解\r一曲線族 未定係數之數目等於原方程式階數 特解\r一曲線 未定係數之數目小於原方程式階數 變數分離型\r型態\r$$f(x)dx=g(y)dy$$\n解法\r兩邊積分即可\n齊次函數型\r型態\r$$M(x, y)dx+N(x,y)dy=0$$ $$其中M與N為齊次函數$$ $$即M(\\lambda x,\\lambda y)=\\lambda^kM(x,y),,N(\\lambda x,\\lambda y)=\\lambda^k(x,y)$$\n解法\r$$\\frac{dy}{dx}=-\\frac{M(x,y)}{N(x,y)}=-\\frac{M(\\lambda x,\\lambda y)}{N(\\lambda x, \\lambda y)}$$ $$令\\lambda=\\frac{1}{x}，得 \\frac{dy}{dx}=-\\frac{M\\left( 1, \\frac{y}{x} \\right)}{N\\left( 1, \\frac{y}{x} \\right)}$$ $$再令y=vx,dy=vdx+xdv$$ $$得 \\frac{dy}{dx}= \\frac{vdx+xdv}{dx}-\\frac{M(1,v)}{N(1, v)}=f(v)$$ $$移項得 \\frac{dv}{f(v)-v}=\\frac{dx}{x}，即可用變數分離型解法求解$$\n例題: $(2x-y+1)dx+(x+y)dy=0$\r$$解: 先平移兩函數使其成為齊次方程式$$\n$$\\begin{cases}2x-y+1=0\\newline x+y=0\\end{cases}$$\n$$得 x=-\\frac{1}{3},y=\\frac{1}{3}$$\n$$令X=x-\\left( -\\frac{1}{3} \\right),Y=y-\\frac{1}{3}$$ $$代回原方程式得(2X-Y)dx+(X+Y)dy=0$$\n$$即可用齊次函數法解$$ $$Ans:\\ln\\left[ 2\\left( \\frac{3x+1}{3} \\right)^2+\\left( \\frac{3y-1}{3} \\right)^2 \\right]=C-\\sqrt{ 2 }\\arctan \\frac{3y-1}{\\sqrt{ 2 }(3x+1)}$$\n任意$(ax+by+c)^kdx+(dx+ey+f)^kdy$型之方程式皆可用此法解\r恰當型\r型態\r$$M(x,y)dx+N(x,y)dy=0$$ $$且存在\\Phi使 \\frac{d\\Phi}{dx}=M(x,y), \\frac{d\\Phi}{dy}=N(x,y) $$ $$即\\frac{\\partial M}{\\partial y}= \\frac{\\partial^2 \\Phi}{\\partial x \\partial y}=\\frac{\\partial N}{\\partial x}$$\n$$(與微積分4的,Green\u0026rsquo;s,Theorem學到的保守函數一樣)$$\n解法\r$$對\\Phi積分得\\Phi=\\int M(x,y) , dx+f(y)=\\int N(x,y) , dy+g(x)$$\n特殊情況:$M(x,y)dx+N(x,y)dy=0，但\\frac{\\partial M}{\\partial y}\\ne \\frac{\\partial N}{\\partial x}，且存在積分因子I(x,y)使 \\frac{\\partial(MI)}{\\partial y}=\\frac{\\partial(NI)}{\\partial x}$\rCase 1: $\\frac{\\frac{\\partial M}{ \\partial y}-\\frac{\\partial N}{\\partial x}}{N}=f(x)$\r$$I=e^{\\int f(x) , dx}$$\n證明\r$$由\\frac{\\partial(MI)}{\\partial y}= \\frac{\\partial(NI)}{\\partial x}可得 M \\frac{\\partial I}{\\partial y}+I \\frac{\\partial M}{\\partial y}=N \\frac{\\partial I}{\\partial x}+I \\frac{\\partial N}{\\partial x}$$ $$且I僅與x有關，故 \\frac{\\partial I}{\\partial y}=0$$ $$移項得I\\left( \\frac{\\partial M}{\\partial y}-\\frac{\\partial N}{\\partial x} \\right)=N \\frac{\\partial I}{\\partial x}$$ $$再移項得\\frac{\\frac{\\partial M}{ \\partial y}-\\frac{\\partial N}{\\partial x}}{N}dx=f(x)dx= \\frac{dI}{I}$$ $$積分可得I=e^{\\int f(x) , dx}$$\nCase 2: $\\frac{\\frac{\\partial M}{ \\partial y}-\\frac{\\partial N}{\\partial x}}{M}=g(x)$\r$$I=e^{\\int g(y) , dy}$$\nCase 3: $M與N皆為x,y的多項式$\r$$令I=x^ay^b，並求解a, b$$\n一階線性ODE\r型態\r$$y\u0026rsquo;+P(x)y=Q(x)$$\n解法\r$$y=\\frac{1}{I}\\int IQ , dx，其中I=e^{\\int P(x) , dx}。$$\n$$微積分2學過，相信大家都還記得(,,・ω・,,)$$\nBernoulli Differential Equation\r型態\r$$y\u0026rsquo;+P(x)y=Q(x)y^a，a\\ne 0, 1$$\n解法\r$$令z=y^{1-a}$$ $$代回原方程式可得 \\frac{1}{1-a}z\u0026rsquo;+P(x)z=Q(x)$$ $$即可用一階線性ODE公式求解。$$\n變數變換法\r解法\r觀察哪一項最特殊，並對其使用變數變換。\n例題: $y\u0026rsquo;=x^2+2xy+y^2+2x+2y,,y(0)=0$\r$$解: 注意到x^2+2xy+y^2+2x+2y=(x+y)^2+2(x+y)$$ $$令z=x+y,,dz=dx+dy，代入即可求解。$$ $$Ans:-\\frac{1}{x+y+1}=x-1$$\nRiccati 方程式\r型態\r$$y\u0026rsquo;=P(x)y^2+Q(x)y+R(x)$$\n解法\r$$令y(x)=s(x)+\\frac{1}{z(x)}$$ $$代回原式可得z\u0026rsquo;+[2P(x)s+Q(x)]z=-P(x)$$ $$即可用一階線性ODE公式求解$$\nClairaut 方程式\r型態\r$$y=xy\u0026rsquo;+f(y\u0026rsquo;)$$\n解法\r$$兩邊微分得y\u0026rsquo;=y\u0026rsquo;+xy\u0026rsquo;\u0026rsquo;+y\u0026rsquo;\u0026rsquo; \\cdot f\u0026rsquo;(y\u0026rsquo;)$$ $$移項得y\u0026rsquo;\u0026rsquo;[x+f\u0026rsquo;(y\u0026rsquo;)]=0，產生2組解:$$ $$(1),若y\u0026rsquo;\u0026rsquo;=0$$ $$積分兩次得y=c_{1}x+c_2，有2個未定係數，與原ODE階數不同$$ $$故須代回原式得c_{1}x+c_{2}=c_{1}x+f(c_{1})$$ $$得c_{2}=f(c_{1}),,y=c_{1}x+f(c_{1})$$\n$$(2),若x+f\u0026rsquo;(y\u0026rsquo;)=0$$ $$令y\u0026rsquo;(x)=g(x)，代回原式得y=xg(x)+f(g(x))$$\n高階ODE\r常係數ODE\r型態\r$$a_{n}y^{(n)}+a_{n-1}y^{(n-1)}+\\dots+a_{1}y\u0026rsquo;+a_{0}y=0$$\n齊次解$y_{h}$解法\r令$y=e^{\\lambda x}，代入得a_{n}\\lambda^{n}+a_{n-1}\\lambda^{n-1}+\\dots+a_{1}\\lambda+a_{0}=0，求出\\lambda的n個根$\n(1) 若所有根均為相異實根\r$$y=c_{1}e^{\\lambda_{1}x}+c_{2}e^{\\lambda_{2}x}+\\dots+c_{n}e^{\\lambda_{n}x}$$\n(2) 存在複數根$a+bi$，必成共軛複數出現\r$$y=c_{1}e^{(a+bi)x}+c_{2}e^{(a-bi)x}=e^{ax}[(c_{1}+c_{2})\\cos bx+i(c_{1}-c_{2})\\sin bx]$$ $$=e^{ax}(C_{1}\\cos bx+C_{2}\\sin bx)$$ (因目前所解的ODE均為實數系，故須將虛數以實數表示)\n(3) 存在$k$個重根，即$\\lambda_{1}=\\lambda_{2}=\\dots=\\lambda_{k}$\r$$y=(c_{0}+c_{1}x+\\dots+c_{k-1}x^{k-1})e^\\lambda x$$\n特解$y_{p}$解法\r觀察法\r觀察具有微分規律的項\n參數變異法，以二階ODE $y\u0026rsquo;\u0026rsquo;+a(x)y\u0026rsquo;+b(x)y=Q(x)$為例\r$$令特解y_{p}=u_{1}(x)y_{1}+u_{2}(x)y_{2}$$ $$此時強加一個條件: u_{1}\u0026lsquo;y_{1}+u_{2}\u0026lsquo;y_{2}=0$$\n$$可得\\begin{cases}u_{1}\u0026lsquo;y_{1}+u_{2}\u0026lsquo;y_{2}=0\\newline u_{1}\u0026lsquo;y_{1}\u0026rsquo;+u_{2}\u0026lsquo;y_{2}\u0026rsquo;=Q(x)\\end{cases}$$ $$即可用克拉瑪公式求得u_\u0026rsquo;{1},u_\u0026rsquo;{2}。$$\n$$再積分即得u_{1},u_{2}$$ $$高階ODE也可用此方法，再加入一些強制條件後求得。$$\nCauchy-Euler 方程式\r型態\r$$a_{n}x^ny^{(n)}+a_{n-1}x^{n-1}y^{(n-1)}+\\dots+b_{1}xy\u0026rsquo;+b_{0}y=Q(x)$$\n齊次解$y_h$解法\r$$令y_{h}=x^m，求出m的n個根。以二階ODE為例$$\n(1) 均為相異實根\r$$y_{h}=c_{1}x^{m_{1}}+c_{2}x^{m_{2}}$$\n(2) 存在複數根，必成共軛複數出現\r$$令m_{1}=a+bi,,m_{2}=a-bi$$ $$代入得y_{h}=x^a[C_{1}\\cos(b\\ln x)+C_{2}\\sin(b\\ln x)]$$\n(3) 存在重根\r$$y_{h}=c_{1}x^m+c_{2}x^m\\ln x$$\n證明\r$$令第二個解y_2=u(x)y_{1}$$ $$代入即可得u(x)=\\ln x$$\n通解解$y_p$解法\r參數變異法 未定係數法 恰當型\r型態\r$$一個n階微分方程a_{n}(x)y^{(n)}+a_{n-1}(x)y^{(n-1)}+\\dots+a_{1}(x)y\u0026rsquo;+a_{0}(x)y=R(x)$$ $$可由另一個n-1階微分方程b_{n-1}(x)y^{(n-1)}+b_{n-2}(x)y^{(n-2)}+\\dots+b_{1}(x)y\u0026rsquo;+b_{0}y=Q(x)微分1次而得$$\n條件\r$a_{0}-a_1\u0026rsquo;+a_{2}\u0026rsquo;\u0026rsquo;-\\dots=0$\n證明\r設原方程式可由另一方程式得到，比較係數即可。\n降階法\r型態\r$$y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=0$$\n$$且已知或易知一解y_{1}$$\n解法\r$$令y_2=u(x)y_{1}$$ $$即可轉換為u\u0026rsquo;的一階微分方程並求解$$\n特殊情況\r(1) $P(x)+xQ(x)=0$\r$$y_{1}=x為一齊次解$$\n(2) $存在一實數C使C^2+CP(X)+Q(X)=0$\r$$y_{1}=e^{ mx}為一齊次解$$\n可化為一階ODE之解法\r$f(x,y\u0026rsquo;,y\u0026rsquo;\u0026rsquo;)=0$\r$$缺y項，令z(x)=y\u0026rsquo;$$\n$f(y,y\u0026rsquo;,y\u0026rsquo;\u0026rsquo;)=0$\r$$缺x項，令z(y)=y\u0026rsquo;$$\n特殊變數代換\r型態\r$y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=R(x)$\n因變數變更法\r解法\r$$令y(x)=u(x)v(x)$$ $$代入原方程式得uv\u0026rsquo;\u0026rsquo;+(2u\u0026rsquo;+Pu)v\u0026rsquo;+(u\u0026rsquo;\u0026rsquo;+Pu\u0026rsquo;+Qu)v=R$$\n$$(1)若u\u0026rsquo;\u0026rsquo;+Pu\u0026rsquo;+Qu=0，則u為原ODE之解$$\n$$代回原式得uv\u0026rsquo;\u0026rsquo;+(2u\u0026rsquo;+Pu)v\u0026rsquo;=R$$ $$可直接用一階ODE公式解出v\u0026rsquo;再積分得到v$$\n$$(2)若2u\u0026rsquo;+Pu=0$$ $$則u=e^{\\int -\\frac{P}{2} , dx}$$ $$代回原式得v\u0026rsquo;\u0026rsquo;+\\left( Q-\\frac{1}{4}P^2-\\frac{1}{2}P\u0026rsquo; \\right)v=\\frac{R}{u}$$\n$$若v\u0026rsquo;\u0026rsquo;+\\left( Q-\\frac{1}{4}P^2-\\frac{1}{2}P\u0026rsquo; \\right)v=C，則解二階常係數ODE即可$$\n$$若v\u0026rsquo;\u0026rsquo;+\\left( Q-\\frac{1}{4}P^2-\\frac{1}{2}P\u0026rsquo; \\right)v=\\frac{C}{x^2}，則得到v\u0026rsquo;\u0026rsquo;+\\frac{C}{x^2}v=\\frac{R}{u}，為Cauchy-Euler方程式$$\n自變數變更法\r解法\r$$令z=z(x)$$ $$整理得 \\frac{d^2y}{dz^2}+\\frac{z\u0026rsquo;\u0026rsquo;+Pz\u0026rsquo;}{(z\u0026rsquo;)^2} \\frac{dy}{dz}+\\frac{Q}{(z\u0026rsquo;)^2}y=\\frac{R}{(z\u0026rsquo;)^2}$$ $$此時若可令 \\frac{Q}{(z\u0026rsquo;)^2}=a, \\frac{z\u0026rsquo;\u0026rsquo;+Pz\u0026rsquo;}{(z\u0026rsquo;)^2}=b，即可化為常係數ODE並求解。$$\nODE之級數解\rFrobenius Method\r型態\r$$y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=0$$\n$$且x=x_{0}為規則異點$$\n解法\r$$y=\\sum^{\\infty}_{n=0} a_n (x-x_0)^{n+r} $$\nLegendre Polynomials\r型態\r$$(1-x^2)y\u0026rsquo;\u0026rsquo;-2xy\u0026rsquo;+n(n+1)y=0$$\n解法\r$$將y=\\sum^\\infty_{i=0}a_{i}x^i代入後可得$$ $$a_{i+2}= \\frac{(i-n)(i+n+1)}{(i+2)(i+1)}a_{i}$$ $$並得解為y(x)=P_n=a_{0}y_{1}+a_{1}y_{2}$$\n$$其中y_{1}是偶函數，y_{2}是奇函數$$\n$$且須滿足P_{n}(1)=1$$\n性質\rRodrigue公式\r$$P_{n}(x)=\\frac{1}{2^nn!} \\frac{d^n}{dx^n}[(x^2-1)^n]$$\n生成函數\r$$(1-2xt+t^2)^{-1/2}=\\sum^\\infty_{n=0}P_{n}(n)t^n$$\nBessel方程式\r型態\r$$x^2y\u0026rsquo;\u0026rsquo;+xy\u0026rsquo;+(x^2-p^2)y=0$$\n解法\r$$用Frobenius,Method可得a_{n}=-\\frac{1}{n(n\\pm2p)}a_{n-2}$$ $$括弧內取正號可求得J_{p}=\\frac{\\sum^\\infty_{n=0}(-1)^nx^{2n+p}}{2^{2n+p}n!\\Gamma(n+p+1)} $$ $$取負號可求得J_{-p}=\\frac{\\sum^\\infty_{n=0}(-1)^nx^{2n-p}}{2^{2n-p}n!\\Gamma(n-p+1)}$$\n$$y=c_{1}J_{p}+c_{2}J_{-p}$$\n性質\r$$若p為整數，則J_p=(-1)^pJ_{-p}$$\n$$此時J_{p}與J_{-p}已不線性獨立，故須尋求另解$$\n第二類Bessel函數\r$$令Y_{p}=\\frac{J_{p}\\cos p\\pi-J_{-p}}{\\sin p\\pi}$$ $$則Bessel方程式的解為y(x)=c_{1}J_{p}+c_{2}Y_{p}$$ $$當p為整數時，用羅必達法則可求得$$\n$$Y_p=\\frac{2}{\\pi} ( \\ln \\frac{x}{2} ) J_n- \\frac{1}{\\pi}\\sum_{m=0}^{n-1} \\frac{(n-m-1)!}{m!} \\frac{x}{2}^{2m-n}- \\frac{1}{\\pi}\\sum^\\infty_{m=0} [\\Phi(m)+ \\Phi(n+m)] \\frac{(-1)^m}{m!(n+m)!} \\frac{x}{2}^{2m+n}$$\n$$其中\\Phi(x)=1+\\frac{1}{2}+\\frac{1}{3}+\\dots+\\frac{1}{p},\\Phi(0)=0$$\n第三類Bessel函數\r$$令H^{(1)}_p(x)=J_p(x)+iY_p(x)$$\n$$H^{(2)}_p(x)=J_p(x)-iY_p(x)$$\n$$得Bessel方程式通解為y(x) = c_1H^{(1)}_p(x) + c_2H^{(2)}_p(x) $$\n修正型Bessel函數\r$$解x^2y\u0026rsquo;\u0026rsquo;+xy\u0026rsquo;-(x^2+p^2)y=0$$\n$$得通解為y(x)=c_{1}J_{p}(ix)+c_{2}Y_{p}(ix)$$\n第一類修正型Bessel函數\r$$令I_{p}(x)=\\sum^\\infty_{m=0} \\frac{x^{2m+p}}{2^{2m+p}m!\\Gamma(p+m+1)}$$\n$$得I_{p}(x)=i^{-p}J_{p}(ix),I_{-p}(x)=i^pJ_{-p}(ix)$$ $$故當p不為整數時，通解y(x)=c_{1}I_{p}(x)+c_{2}I_{-p}(x)$$\n第二類修正型Bessel函數\r$$令K_p(x)=\\frac{\\pi}{2} \\frac{I_{-p}(x)-I_{p}(x)}{\\sin p\\pi}$$\n$$則通解可寫為y(x)=c_{1}I_{p}(x)+c_{2}K_{p}(x)，p\\in R$$\nBessel函數之微分\r$$\\frac{d}{dx}[x^pJ_{p}(x)]=x^pJ_{p-1}(x)$$\n$$\\frac{d}{dx}[x^{-p}J_{p}(x)]=-x^{-p}J_{p+1}(x)$$\n$$pJ_{p}(x)+xJ_\u0026lsquo;p(x)=J_{p-1}(x)$$\n$$pJ_{p}(x)+xJ_\u0026lsquo;p(x)=xJ_{p-1}(x)$$\n$$-pJ_{p}(x)+xJ_\u0026lsquo;p(x)=-xJ_{p+1}(x)$$\n$$J_{p+1}(x)=\\frac{2p}{x}J_{p}(x)-J_{p-1}(x)$$\n半階Bessel函數\r$$J_{\\frac{1}{2}}(x)= \\sqrt{ \\frac{2}{\\pi x} }\\sin x$$\n$$J_{-\\frac{1}{2}}(x)= \\sqrt{ \\frac{2}{\\pi x} }\\cos x$$\n$$I_{\\frac{1}{2}}(x)= \\sqrt{ \\frac{2}{\\pi x} }\\sinh x$$\n$$I_{-\\frac{1}{2}}(x)= \\sqrt{ \\frac{2}{\\pi x} }\\cosh x$$\n後記\r把工程數學學習要訣上冊打完3/8了(灑花)。\n發現還有下冊ヾ(;ﾟ;Д;ﾟ;)ﾉﾞ\n還好有Obsidian有Latex的快捷輸入 我才花比較少時間。\n原本Notion上寫 寫到快懷疑人生。\n還有架網站也花了蠻多時間的(畢竟我平常也不會沒事去架網站) ","date":"2024-08-01T00:00:00Z","image":"http://localhost:1313/p/%E5%B7%A5%E7%A8%8B%E6%95%B8%E5%AD%B8-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86/images_hu16463020377908497126.png","permalink":"http://localhost:1313/p/%E5%B7%A5%E7%A8%8B%E6%95%B8%E5%AD%B8-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86/","title":"工程數學-常微分方程 重點整理"},{"content":"題目\r連結: Problem - 1804G - Codeforces 前置知識: 線段樹 難度: 3500 題解\r本題解主要參考自CF1804G - 洛谷专栏 (luogu.com.cn)\n根據題意，此題需要以下操作:\n加入一個用戶 刪除一個用戶 全體加$1$ 全體除$2$ 求全體和 對於全體除$2$操作，我們找到一個元素均相同的區間，接著全體減去該值的一半即可。由此可知，以上操作均可以透過線段樹(Segment Tree)完成。\n我們先將時間離散化，用掃描線遍歷所有加入/刪除用戶的時間點，接著根據兩個時間點的差進行計算即可。若此時所有元素的總和$\u0026gt;b$，則全體除$2$；否則全體加$1$。我們發現以上操作可構成一個循環，可藉此提高運算速度。\n詳細內容可見程式碼註解。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 200005; int n, b; int s[maxn], f[maxn], d[maxn]; int tim[maxn \u0026lt;\u0026lt; 1], t; vector\u0026lt;int\u0026gt; add[maxn \u0026lt;\u0026lt; 1], del[maxn \u0026lt;\u0026lt; 1]; ll res; struct SegmentTree { int mx[maxn \u0026lt;\u0026lt; 2], mn[maxn \u0026lt;\u0026lt; 2], lazy[maxn \u0026lt;\u0026lt; 2], cnt[maxn \u0026lt;\u0026lt; 2]; ll sum[maxn \u0026lt;\u0026lt; 2]; #define lc (i \u0026lt;\u0026lt; 1) #define rc (i \u0026lt;\u0026lt; 1 | 1) void pushup(int i) { sum[i] = sum[lc] + sum[rc]; mx[i] = max(mx[lc], mx[rc]); mn[i] = min(mn[lc], mn[rc]); cnt[i] = cnt[lc] + cnt[rc]; } void add(int i, int v) { sum[i] += 1ll * cnt[i] * v; mx[i] += v; mn[i] += v; lazy[i] += v; } void pushdown(int i) { if (!lazy[i]) return; add(lc, lazy[i]); add(rc, lazy[i]); lazy[i] = 0; } void upd(int i, int l, int r, int p, int v, int c) { if (l == r) { sum[i] = mx[i] = mn[i] = v; cnt[i] = c; } else { pushdown(i); int mid = l + r \u0026gt;\u0026gt; 1; if (mid \u0026gt;= p) upd(lc, l, mid, p, v, c); else upd(rc, mid + 1, r, p, v, c); pushup(i); } } void upd_add(int i, int l, int r, int ql, int qr, int v) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) add(i, v); else { pushdown(i); int mid = l + r \u0026gt;\u0026gt; 1; if (mid \u0026gt;= ql) upd_add(lc, l, mid, ql, qr, v); if (mid \u0026lt; qr) upd_add(rc, mid + 1, r, ql, qr, v); pushup(i); } } void upd_div(int i, int l, int r, int ql, int qr) { // 此區間都是同一個值，直接區間減 if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr \u0026amp;\u0026amp; (mn[i] + 1) / 2 == (mx[i] + 1) / 2) { add(i, -(mn[i] + 1) / 2); return; } pushdown(i); int mid = l + r \u0026gt;\u0026gt; 1; if (mid \u0026gt;= ql) upd_div(lc, l, mid, ql, qr); if (mid \u0026lt; qr) upd_div(rc, mid + 1, r, ql, qr); pushup(i); } void solve(int interval) { if (cnt[1] == 0) return; while (interval \u0026amp;\u0026amp; sum[1] \u0026gt; b) { interval--; upd_div(1, 1, n, 1, n); } while (interval) { int curmin = mn[1], curmax = mx[1]; int k = min((int)(b - sum[1]) / cnt[1] + 1, interval); ll s = sum[1] * k + 1ll * cnt[1] * k * (k - 1) / 2; upd_add(1, 1, n, 1, n, k); interval -= k; res += s; while (interval \u0026amp;\u0026amp; sum[1] \u0026gt; b) { interval--; k++; upd_div(1, 1, n, 1, n); } if (mn[1] == curmin \u0026amp;\u0026amp; mx[1] == curmax) { res += s * (interval / k); interval %= k; } } } } st; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; f[i] \u0026gt;\u0026gt; d[i]; f[i]++; tim[++t] = s[i]; tim[++t] = f[i]; } // 離散化 sort(tim + 1, tim + 1 + t); t = unique(tim + 1, tim + 1 + t) - tim - 1; for (int i = 1; i \u0026lt;= n; i++) { s[i] = lower_bound(tim + 1, tim + 1 + t, s[i]) - tim; f[i] = lower_bound(tim + 1, tim + 1 + t, f[i]) - tim; add[s[i]].emplace_back(i); del[f[i]].emplace_back(i); } for (int i = 1; i \u0026lt; t; i++) { for (int j = 0; j \u0026lt; add[i].size(); j++) { st.upd(1, 1, n, add[i][j], d[add[i][j]], 1); } for (int j = 0; j \u0026lt; del[i].size(); j++) { st.upd(1, 1, n, del[i][j], 0, 0); } st.solve(tim[i + 1] - tim[i]); } cout \u0026lt;\u0026lt; res; } ","date":"2024-07-31T00:00:00Z","permalink":"http://localhost:1313/p/cf1804g-flow-control-%E9%A1%8C%E8%A7%A3/","title":"CF1804G Flow Control 題解"},{"content":"題目\r連結: Problem - 1033G - Codeforces 前置知識: 無 難度: 3500 題解\r本題解主要參考自zsc9852462的題解。本文將我當時看這篇題解有理解困難的地方更加詳細的說明，以及改正原文的一些小錯誤。\n首先，我們發現Alice必勝與Bob必勝本質是相同的，皆為$\\frac{m^2-w_{f}-w_{s}}{2}$，因此只須考慮先手必勝跟後手必勝的情況。\n容易看出將$v_i$對$(a+b)$取模並不會影響結果，因此我們令$w_{i}=v_{i}\\mod(a+b)$。\n假設$a\\leq b$，則$w_i$只可能會是以下4種情況:\n$0\\leq w_{i}\u0026lt;a$: 該堆無法被任何人取 $a\\leq w_{i}\u0026lt;b$: Alice取完會變情況1，Bob不能取。若$a=b$則不會有此情況。 $b\\leq w_{i}\u0026lt;2a$: Alice或Bob取完都會變情況1。若$b\\geq 2a$則不會有此情況。 $max(2a,b)\\leq w_{i}\u0026lt;x+y$: Alice取完會變情況2，Bob取完會變情況1。若$a=b$則不會有此情況。 接著對各種情況進行討論。另$c_{i}$為第$i$種類型的堆的數量:\n$c_{2}\\geq 1$: Alice必勝 $c_{2}=0$ $c_{4}\\geq 2$: Alice必勝 $c_{4}=1$: $c_{3}$為奇數: Alice必勝 $c_{3}$為偶數: 先手必勝 $c_{4}=0$: $c_{3}$為奇數: Alice必勝 $c_{3}$為偶數: 後手必勝 我們只關心先手必勝跟後手必勝，將其條件整理如下:\n先手必勝: $c_{2}=0$且$c_{4}=1$且$c_{3}$為偶數。 後手必勝: $c_{2}=0$且$c_{4}=0$且$c_{3}$為偶數。 將以上條件轉換為數學式:\n先手必勝: $\\forall w_{i},w_{i}\\notin[a,b),\\sum[w_{i}\\geq max(2a,b)]=1,\\sum[w_{i}\\geq b]\\mod 1=1$ 後手必勝: $\\forall w_{i},w_{i}\\notin[a,b),\\sum[w_{i}\\geq max(2a,b)]=0,\\sum[w_{i}\\geq b]\\mod 1=0$ 我們可以枚舉$sum=a+b$，對$v_{i}$取模後排序$w_{i}$。因為在先手必勝或後手必勝的情況下$\\forall w_{i},w_{i}\\notin[a,b)$，故存在$i$使得$w_{i}\u0026lt;a,b\\leq w_{i+1}$。我們接著枚舉符合此條件的$w_{i}$。\n先手必勝時$\\sum[w_{i}\\geq max(2a,b)]=1$。由於我們已將$w_{i}$排序過，故前式等價於$max(2a,b)\u0026gt;w_{n-1}$。\n我們令$w_{n}=sum-1$，即模$sum$下的最大值。如果$b\u0026gt;2a$，代表$w_{n-1}\u0026lt;b\\leq w_{n}\\implies w_{n-1}\u0026lt;a\\leq w_{n}$。因為$b\u0026gt;2a\u0026gt;a$，故也可推得$w_{n-1}\u0026lt;2a\\leq w_{n}$。\n把$a\\leq b$的條件解除，由上面推導我們可得出$a,b\\in[l,r]$，其中$l=max\\left( w_{i},\\left\\lfloor \\frac{w_{n-1}}{2} \\right\\rfloor \\right)+1,r=min(w_{i+1},m)$。再由$b=sum-a$我們可以得到$a\\in[max(l,sum-r),min(r,sum-l)]$。\n由於一個$a$對應一個$b$，所以$min(r,sum-l)-max(l,sum-r)+1$就是當時枚舉的$sum$對答案的貢獻。\n後手同理。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 105; ll n, m; ll v[maxn], w[maxn]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; ll wf = 0, ws = 0; for (int sum = 2; sum \u0026lt;= 2 * m; sum++) { for (int i = 1; i \u0026lt;= n; i++) w[i] = v[i] % sum; sort(w + 1, w + 1 + n); w[n + 1] = sum - 1;\t// 插入最大值 for (int i = 0; i \u0026lt;= n; i++) {\t// w[i] \u0026lt; a, b \u0026lt;= w[i + 1] if ((n - i) \u0026amp; 1) {\t// w[i] \u0026gt;= b的數量為奇數，計算先手必勝 ll l = max(w[i], w[n - 1] / 2) + 1, r = min(w[i + 1], m); wf += max(0ll, min(r, sum - l) - max(l, sum - r) + 1); } else {\t// w[i] \u0026gt;= b的數量為偶數，計算後手必勝 ll l = max(w[i], w[n] / 2) + 1, r = min(w[i + 1], m); ws += max(0ll, min(r, sum - l) - max(l, sum - r) + 1); } } } cout \u0026lt;\u0026lt; (m * m - wf - ws) / 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (m * m - wf - ws) / 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; wf \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ws; } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1033g-chip-games-%E9%A1%8C%E8%A7%A3/","title":"CF1033G Chip Games 題解"},{"content":"題目\r連結: Problem - 1830E - Codeforces 前置知識: CDQ分治 難度: 3500 題解\r本題解主要參考自Alex_Wei的題解。\n由於發現一個數的移動次數太難直接求得，因此嘗試找尋不變量或易求出的量的關係。\n考慮兩個易取得的量$\\sum\\mid i-p_{i}\\mid$跟逆序對數$\\sum_{i\u0026lt;j}[p_{i}\u0026gt;p_{j}]$，前者可以透過線性維護，後者可以透過CDQ分治取得。\n根據題意我們可以發現$i\u0026lt;p_{i},i\\geq p_{j},j\\leq p_{i},j\u0026gt;p_{j}$。在$(i, j)$的$1$次交換中，會使$\\sum\\mid i-p_{i}\\mid$減少$\\mid i-p_{i}|+|j-p_{j}|-|j-p_{i}|-|i-p_{j}|=2(j-i)$，逆序對數$\\sum_{i\u0026lt;j}[p_{i}\u0026gt;p_{j}]$減少$2(j-i)-1$。\n在總共$f(p)$次交換中，$\\sum\\mid i-p_{i}\\mid$共會減少$2f(p)(j-i)$，$\\sum_{i\u0026lt;j}[p_{i}\u0026gt;p_{j}]$共會減少$2f(p)(j-i)-f(p)$。顯然這兩個量在排序完成時都會是$0$。由此可得$f(p)=\\sum\\mid i-p_{i}\\mid-\\sum_{i\u0026lt;j}[p_{i}\u0026gt;p_{j}]$。\n時間複雜度$O(n\\log n+q\\log^2n)$\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 500005, maxq = 50005; int n, q; int cnt; int p[maxn]; int coe[maxq]; int bit[maxn]; void add(int i, int v) { while (i \u0026lt;= n) { bit[i] += v; i += i \u0026amp; -i; } } int query(int i) { int res = 0; while (i) { res += bit[i]; i -= i \u0026amp; -i; } return res; } int query(int l, int r) { return query(r) - query(l - 1); } struct { int x, y, z, w, id; } c[maxn + maxq * 6], d[maxn + maxq * 6]; ll inv[maxq], res[maxq]; void solve(int l, int r) { if (l == r || r \u0026lt;= n) return; int mid = l + r \u0026gt;\u0026gt; 1; if (l == 1 \u0026amp;\u0026amp; r == cnt) mid = n; solve(l, mid); solve(mid + 1, r); int pl = l, pr = mid + 1, p = l; auto ml = [\u0026amp;]() { if (!c[pl].id) add(c[pl].y, c[pl].w); d[p++] = c[pl++]; }; auto mr = [\u0026amp;]() { if(c[pr].id) inv[c[pr].id] += c[pr].w * query(c[pr].y, c[pr].z); d[p++] = c[pr++]; }; while (pl \u0026lt;= mid \u0026amp;\u0026amp; pr \u0026lt;= r) { if (c[pl].x \u0026lt;= c[pr].x) ml(); else mr(); } while (pl \u0026lt;= mid) ml(); while (pr \u0026lt;= r) mr(); for (int i = l; i \u0026lt;= mid; i++) { if (!c[i].id) add(c[i].y, -c[i].w); } for (int i = l; i \u0026lt;= r; i++) c[i] = d[i]; } int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i]; res[0] += abs(i - p[i]); add(p[i], 1); inv[0] += i - query(p[i]); c[++cnt] = {i, p[i], 0, 1, 0}; } for (int i = 1; i \u0026lt;= n; i++) bit[i] = 0; for (int i = 1; i \u0026lt;= q; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; res[i] = res[i - 1]; res[i] -= abs(p[x] - x) + abs(p[y] - y); res[i] += abs(p[x] - y) + abs(p[y] - x); int mn = min(p[x], p[y]), mx = max(p[x], p[y]); coe[i] = p[x] \u0026gt; p[y] ? -1 : 1; c[++cnt] = {x, p[x], 0, -1, 0}; c[++cnt] = {y, p[y], 0, -1, 0}; c[++cnt] = {x, p[y], 0, 1, 0}; c[++cnt] = {y, p[x], 0, 1, 0}; if (x + 1 \u0026lt; y) { c[++cnt] = {x, mn, mx, -1, i}; c[++cnt] = {y - 1, mn, mx, 1, i}; } swap(p[x], p[y]); } solve(1, cnt); for (int i = 1; i \u0026lt;= q; i++) { inv[i] = (inv[i] * 2 + 1) * coe[i] + inv[i - 1]; cout \u0026lt;\u0026lt; (res[i] - inv[i]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1830e-bully-sort-%E9%A1%8C%E8%A7%A3/","title":"CF1830E Bully Sort 題解"},{"content":"題目\r連結: Problem - 1835E - Codeforces 前置知識: DP 難度: 3500 題解\r本題解主要參考自tcz_wk在洛谷上的題解\n首先，注意到當一個字符在序列中不是第一次出現，由於我們已在第1次輸入該字符時知道它的鍵位，因此只需再按1次該鍵即可。故我們只需關心這個序列中出現了多少不同的數。\n設$C$為序列中出現的不同的字符的集合，大小為$A$；$X$為序列中並未出現，但是鍵盤上有該字符的集合，大小為$B$(等於$m-A$)。\n接著根據我們在輸入過程中可能會有的狀況，設立三個$dp$狀態:\n$f[i][j]$表示已經知道backspace在哪裡，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 $g[i][j]$表示尚未知道backspace在哪裡，目前螢幕上顯示的序列$並非$目標序列的前綴，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 $h[i][j]$表示尚未知道backspace在哪裡，目前螢幕上顯示的序列為目標序列的前綴，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 接下來我們考慮$f[i][j]$的轉移，共3種情況:\n有$\\frac{1}{i+j}$的機率按下正確的字符，貢獻為$f[i - 1][j] + 1$ 有$\\frac{i-1}{i+j}$的機率按下錯誤的字符，且該字符在$C$中，貢獻為$f[i-1][j]+3$。加3是因為按下這個鍵後，要按backspace把它刪掉，等之後再遇到時還要再按一次。 有$\\frac{j}{i+j}$的機率按下錯誤的字符，且該字符在$X$中，貢獻為$f[i][j-1]+2$ 考慮$g[i][j]$的轉移，共3種情況:\n有$\\frac{1}{i+j+1}$的機率按下backspace，貢獻為$f[i][j] + 1$ 有$\\frac{i}{i+j+1}$的機率按下$C$中的鍵，貢獻為$g[i-1][j]+3$。加$3$的理由跟$f$中提到的一樣。 有$\\frac{j}{i+j+1}$的機率按下$X$中的鍵，貢獻為$g[i][j-1]+2$ 考慮$h[i][j]$的轉移，共4種情況:\n有$\\frac{1}{i+j+1}$的機率按下正確的字符，貢獻為$h[i-1][j]+1$ 有$\\frac{i-1}{i+j+1}$的機率按下不是正確但是位於$C$中的字符，貢獻為$g[i-1][j]+3$ 有$\\frac{j}{i+j+1}$的機率按下$X$中的字符，貢獻為$g[i][j-1]+2$ 有$\\frac{1}{i+j+1}$的機率按下backspace，貢獻為$f[i][j]+2$ 最後考慮第$1$步對結果的貢獻。\n有$\\frac{1}{m+1}$的機率按下backspace，貢獻為$f[a][b]+1$ 有$\\frac{1}{m+1}$的機率按下正確的字符，貢獻為$h[a-1][b]+1$ 有$\\frac{a-1}{m+1}$的機率按下錯誤的字符，且該字符在C中(即未來會出現)，貢獻為$g[a-1][b]+3$ 有$\\frac{1}{m+1}$的機率按下錯誤的字符，且該字符在$X$中(即未來不會出現)，貢獻為$g[a][b-1]+2$ 記得將答案初始設為$n-a$(即目標序列中不是第一次出現的字符的數量)，因為我們在轉移中不會考慮其對答案的貢獻。\n時間複雜度為$O(n^2)$。\n個人認為這題難度相較於其他$3500$分的題目，算是簡單了不少，因為本菜雞在看其他$3500$難度的題目時，常常連題解也看不懂.w.\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxm = 1005; const int mod = 1e9 + 7; int n, m; int inv[maxm]; int f[maxm][maxm], g[maxm][maxm], h[maxm][maxm]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; inv[0] = inv[1] = 1; unordered_set\u0026lt;int\u0026gt; s; for (int i = 2; i \u0026lt;= m + 1; i++) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; for (int i = 1, x; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; s.insert(x); } int a = s.size(), b = m - a; for (int i = 1; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { f[i][j] = 1ll * (i - 1) * inv[i + j] % mod * (f[i - 1][j] + 3) % mod; f[i][j] = (f[i][j] + 1ll * inv[i + j] * (f[i - 1][j] + 1)) % mod; if (j) f[i][j] = (f[i][j] + 1ll * inv[i + j] * j % mod * (f[i][j - 1] + 2)) % mod; } } for (int i = 0; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { g[i][j] = 1ll * inv[i + j + 1] * f[i][j] % mod; if (i) g[i][j] = (g[i][j] + 1ll * inv[i + j + 1] * i % mod * (g[i - 1][j] + 3)) % mod; if (j) g[i][j] = (g[i][j] + 1ll * inv[i + j + 1] * j % mod * (g[i][j - 1] + 2)) % mod; } } for (int i = 1; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { h[i][j] = 1ll * inv[i + j + 1] * (h[i - 1][j] + 1) % mod; h[i][j] = (h[i][j] + 1ll * (i - 1) * inv[i + j + 1] % mod * (g[i - 1][j] + 3)) % mod; h[i][j] = (h[i][j] + 1ll * inv[i + j + 1] * (f[i][j] + 2)) % mod; if (j) h[i][j] = (h[i][j] + 1ll * j * inv[i + j + 1] % mod * (g[i][j - 1] + 2)) % mod; } } int res = n - a; res = (res + 1ll * inv[m + 1] * (f[a][b] + 1)) % mod; res = (res + 1ll * inv[m + 1] * (h[a - 1][b] + 1)) % mod; res = (res + 1ll * inv[m + 1] * (a - 1) % mod * (g[a - 1][b] + 3)) % mod; res = (res + 1ll * inv[m + 1] * b % mod * (g[a][b - 1] + 2)) % mod; cout \u0026lt;\u0026lt; res; } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1835e-old-mobile-%E9%A1%8C%E8%A7%A3/","title":"CF1835E Old Mobile 題解"},{"content":"題目\r連結: Problem - 1994H - Codeforces 前置知識: 無 難度: 3500 題解\r本題解主要參考自大佬$jiangly$的程式碼。\n本題限制$p + 1 \u0026lt; m$，所以我們可以透過查詢\u0026quot;$aa$\u0026ldquo;得到$p + 1$的值。\n接著我們另$s=$\u0026quot;$zzzzzzzzzz$\u0026quot;(10個$z$)，並查詢$s$得到$hash=(26+26p^1+26p^2+\\dots+26p^9)\\mod m$。令其值為$a_{0}+a_{1}p+a_{2}p^2+\\dots+cp^i$。將$c$與$i$記錄下來。\n此時我們知道$cp^i\u0026lt;m,(c+1)p^i\\geq m$，若$c\u0026lt;25$，則我們令$s$的第$i$個字符為$z-(c+1)$ (使用ASCII編碼)。接著再查詢更新過的$s$，得到$new_hash=(26+26p+26p^2+\\dots+(26-c-1)p^i+\\dots+26p^9)\\mod m$。\n將$new_hash$減去$hash$得到$-(c+1)p^i\\mod m$。由$(c+1)p^i\\geq m$可得知$-(c+1)p^i\\leq m$，故$-(c+1)p^i\\mod m=-(c+1)p^i+m$。將其加上$(c+1)p^i$即可得到$m$的值。\n若$c=25$，則我們令$s$的第$i+1$個字符為$z-1=y$。接著查詢更新過的$s$，得到$new_hash=(26+26p+26p^2+\\dots+26p^i+25p^{i+1}+\\dots+26p^9)\\mod m$。將其減去$hash$得到$-p^{i+1}\\mod m=-p^{i+1}+m$，再加上$p^{i+1}$即可得到$m$的值。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; void solve() { int p; cout \u0026lt;\u0026lt; \u0026#34;? aa\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; p; p--; string s(10, \u0026#39;z\u0026#39;); int hash, c; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; hash; c = hash; int i = 0; ll pw = 1; // hash = (26 + 26p + 26p^2 + ... + 26p^9) mod m = a_0 + a_1p + a_2p^2 + ... + c*p^i // pw = p^i while (c \u0026gt;= p) { c /= p; pw *= p; i++; } if (c \u0026lt; 25) { // new_hash = (26 + 26p + 26p^2 + ... + (26 - c - 1)p^i + ... + 26p^9) mod m // pw = (c + 1)p^i // new_hash - hash = (-c - 1)p^i mod m. We know that c*p^i \u0026lt; m and (c + 1)p^i \u0026gt;= m // thus (-c - 1)p^i mod m = (-c - 1)p^i + m s[i] -= c + 1; pw *= c + 1; } else { // new_hash = (26 + 26p + 26p^2 + ... + 25p^(i+1) + ... + 26p^9) mod m // pw = p^(i + 1) s[i + 1]--; pw *= p; } // new_hash - hash = (-c - 1)p^i + m int new_hash; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; new_hash; cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; new_hash + pw - hash \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1994h-fortnite-%E9%A1%8C%E8%A7%A3/","title":"CF1994H Fortnite 題解"},{"content":"題目\r連結: Problem - 1349D - Codeforces 前置知識: 高斯消元 難度: 3200 題解\r本題解主要參考自官方題解\n首先令使第$i$個人擁有全部餅乾的期望時間為$E_i$。答案$E$即為$\\sum^n_{i=1}E_{i}$。\n令$P_{i}$為遊戲結束時所有餅乾在第$i$個人手上的機率。不難得到$\\sum^n_{i=1}P_i=0$。\n此時我們稍微改變遊戲規則，令遊戲只在第$i$個人拿到所有餅乾時才結束(與原遊戲規則的差別為，$i$以外的人拿到所有餅乾時不會結束)。此時的遊戲的期望時間為$E_i\u0026rsquo;$。\n然後我們再令$C$為當某人持有全部餅乾時，將此人的餅乾全部轉移至另一個人所需的期望時間。此時我們可以得到以下等式: $$E_{x}=E_{x}\u0026rsquo;-\\sum^n_{i=1}[i\\ne x](P_{i}\\cdot C+E_{i})$$ 將其移項後即可得到:$$\\sum^n_{i=1}E_{i}=E_{x}\u0026rsquo;-C\\sum^n_{i=1}[i \\ne x]P_{i}$$ 再將上式從$x=1到n$做加總:$$n\\sum^n_{i=1}E_{i}=\\sum^n_{i=1}E_{i}\u0026rsquo;-C(n-1)\\sum^n_{i=1}P_{i}$$ 已知答案$E$為$\\sum^n_{i=1}E_{i}$，且$\\sum^n_{i=1}P_{i}=1$。故我們可將上式簡化為:$$n \\cdot E=\\sum^n_{i=1}E_{i}\u0026rsquo;-C(n-1)$$此時我們令$f_{i}$為當一個人擁有$i$個餅乾時，使此人擁有所有餅乾的期望時間，則我們可以得出$E_{i}\u0026rsquo;=f_{a_{i}},,C=f_{0}$。令$m$為總餅乾數，我們不難得出以下遞推式: $$f_{i}=\\begin{cases} 1 + \\frac{m-i}{m}\\left( \\frac{1}{n-1}f_{i+1}+\\frac{n-2}{n}f_{i} \\right)+\\frac{i}{m}f_{i-1}, \u0026amp;0\u0026lt;i\u0026lt;m \\newline 1+\\frac{1}{n-1}f_{0}+ \\frac{n-2}{n-1}f_{1}, \u0026amp;i=0 \\newline 0, \u0026amp;i=m\\end{cases}$$\n然而，我們在透過消元解以上方程式時，可能會出現主元為$0$的情況。為了避免，我們令$g_{i}=f_{i}-f_{i+1},g_{0}=0,g_{m}=0$，可以得出$f_{i}=\\sum^m_{j=i}g_{j}$。\n於是，我們可以將$f_{i}$在$0\u0026lt;i\u0026lt;m$的情況寫為:$$\\sum^m_{j=i}g_{j}=1 + \\frac{m-i}{m}\\left( \\frac{1}{n-1}\\sum^m_{j=i+1}g_{j}+\\frac{n-2}{n}\\sum^m_{j=i}g_{j} \\right)+\\frac{i}{m}\\sum^m_{j=i-1}g_{j}$$ 相消之後可以得到:$$g_{i}=1+\\frac{(m-i)(n-2)}{m(n-1)}g_{i}+\\frac{i}{m}(g_{i}+g_{i-1})$$ $$g_{i}=\\frac{m(n-1)+i(n-1)g_{i-1}}{m-i}$$ 這樣就不會產生主元為$0$的情況了。\n這題還有用鞅與停時定理的解法，有興趣的人可以上網找找看。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int M = 998244353; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % M; a = a * a % M; b \u0026gt;\u0026gt;= 1; } return res; } const int maxn = 100005, maxm = 300005; int n, m; int a[maxn]; ll res[maxm]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; m += a[i]; } ll invm = qpow(m, M - 2), invn1 = qpow(n - 1, M - 2); for (int i = m; i \u0026gt;= 1; i--) { ll k1 = i * invm % M * invn1 % M, k2 = (m - i) * invm % M; res[i] = (k2 * res[i + 1] + 1) % M * qpow(k1, M - 2) % M; } for (int i = 1; i \u0026lt;= m; i++) res[i] = (res[i] + res[i - 1]) % M; ll s = 0; for (int i = 1; i \u0026lt;= n; i++) s = (s + res[m - a[i]]) % M; s = (s + M - res[m] * (n - 1) % M) % M; cout \u0026lt;\u0026lt; s * qpow(n, M - 2) % M; } ","date":"2024-07-22T00:00:00Z","permalink":"http://localhost:1313/p/cf1349d-slime-and-biscuits-%E9%A1%8C%E8%A7%A3/","title":"CF1349D Slime and Biscuits 題解"},{"content":"題目\r連結: Problem - 963E - Codeforces 前置知識: 帶狀矩陣消元 難度: 3100 題解\r本題解主要參考自浅谈高斯消元拓展之 band-matrix - 洛谷专栏 (luogu.com.cn)。在看本題解前若不知道帶狀矩陣消元是什麼的話，可以先看看這篇，作者寫得很清楚。\n令$f[x][y]$為從座標$(x, y)$走出圓外所需的期望步數。首先依據題意我們可以得到對於所有$x^2+y^2\\leq R^2$: $$f[x][y]=a_{1}f[x-1][y]+a_{2}f[x][y-1]+a_{3}f[x+1][y]+a_{4}f[x][y+1]$$將其移項後即可得到$$f[x][y]-a_{1}f[x-1][y]-a_{2}f[x][y-1]-a_{3}f[x+1][y]-a_{4}f[x][y+1]=1$$ 此時就可以用高斯消元得到答案，然而時間複雜度太大，我們需要想出更有效率的解法。\n將圓內的每個點$(x, y)$從左至右，從上而下依次編號。然後我們可以發現$(x-1, y), (x+1, y)$與$(x, y)$的編號差距為$1$，$(x, y-1),(x,y+1)$與$(x,y)$的編號差距$\\leq R$，因此在係數矩陣中的帶寬最多為$R$，故可以使用帶狀高斯消元來減少複雜度。\u0026gt;)\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxa = 8000; const ll mod = 1e9 + 7; ll r, a1, a2, a3, a4, sum; int id[105][105], n, band; int g[maxa][maxa], res[maxa]; #define ID(x, y) id[x + 50][y + 50] vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pos; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } void gauss(int n, int band) { for (int i = 1; i \u0026lt;= n; i++) { if (!g[i][i]) { for (int j = i + 1; j \u0026lt;= min(n, i + band); j++) { if (g[j][i]) { swap(g[i], g[j]); break; } } } if (!g[i][i]) continue; ll inv = qpow(g[i][i], mod - 2); for (int j = i + 1; j \u0026lt;= min(i + band, n); j++) { ll div = g[j][i] * inv % mod; for (int k = i; k \u0026lt;= min(i + 2 * band, n); k++) { g[j][k] = (g[j][k] - div * g[i][k] % mod + mod) % mod; } g[j][n + 1] = (g[j][n + 1] - div * g[i][n + 1] % mod + mod) % mod; } } for (int i = n; i \u0026gt;= 1; i--) { res[i] = g[i][n + 1]; for (int j = i + 1; j \u0026lt;= min(i + 2 * band, n); j++) { res[i] = (res[i] - 1ll * g[i][j] * res[j] % mod + mod) % mod; } res[i] = res[i] * qpow(g[i][i], mod - 2) % mod; } } int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; a1 \u0026gt;\u0026gt; a2 \u0026gt;\u0026gt; a3 \u0026gt;\u0026gt; a4; sum = a1 + a2 + a3 + a4; sum = qpow(sum, mod - 2); a1 = a1 * sum % mod; a2 = a2 * sum % mod; a3 = a3 * sum % mod; a4 = a4 * sum % mod; for (int i = -r; i \u0026lt;= r; ++i) { for (int j = -r; j \u0026lt;= r; ++j) { if (i * i + j * j \u0026gt; r * r) continue; pos.push_back(make_pair(i, j)); ID(i, j) = pos.size(); } } n = pos.size(); band = 1; // res[x][y] - a1 * res[x - 1][y] - a2 * res[x][y - 1] - a3 * res[x + 1][y] - a4 * res[x][y + 1] for (auto u : pos) { int x = u.first, y = u.second; g[ID(x, y)][ID(x, y)] = 1; g[ID(x, y)][n + 1] = 1; if (ID(x - 1, y)) { g[ID(x, y)][ID(x - 1, y)] = -a1 + mod; band = max(band, abs(ID(x, y) - ID(x - 1, y))); } if (ID(x, y - 1)) { g[ID(x, y)][ID(x, y - 1)] = -a2 + mod; band = max(band, abs(ID(x, y) - ID(x, y - 1))); } if (ID(x + 1, y)) { g[ID(x, y)][ID(x + 1, y)] = -a3 + mod; band = max(band, abs(ID(x, y) - ID(x + 1, y))); } if (ID(x, y + 1)) { g[ID(x, y)][ID(x, y + 1)] = -a4 + mod; band = max(band, abs(ID(x, y) - ID(x, y + 1))); } } gauss(n, band); cout \u0026lt;\u0026lt; res[ID(0, 0)]; } ","date":"2024-07-22T00:00:00Z","permalink":"http://localhost:1313/p/cf963e-circles-of-waiting-%E9%A1%8C%E8%A7%A3/","title":"CF963E Circles of Waiting 題解"},{"content":"題目\r連結: Problem - 1428H - Codeforces 前置知識: 二分搜尋 難度: 3500 題解\r本題解主要參考自官方題解\n為了方便起見，我們將把弧順時針旋轉的操作改為將其移至右邊，逆時針旋轉的操作改為將其移至左邊，並以$C_0$代表第0條弧。\n本演算法分為兩個階段: 移動階段與搜尋階段。\n首先要得出一個重要的結論: 當我們將$C_0$右移時，若未被阻擋的光線$a$較原先增加，則說明$C_0$原先左端點的位置並無其他圓弧。然後我們繼續將$C_0$向右移動，若在一次移動的過程中$a$沒有增加，則說明在這次移動前$C_0$與其他的弧完全重合。此即為移動階段。\n此時我們將$C_0$左移1格(即回至與其他弧重疊的位置)，並令其左端點為$x$。\n接著進入搜尋階段，開始搜尋與$C_0$重疊的那條弧。令$S$為尚未知道位置的弧(一開始為弧$1到n-1$)的集合，並令$T$為所有可能與$C_0$重疊的弧的集合，以及$F$為待會要左移以測試是否與$C_0$重疊的弧的集合。\n至於搜尋的方法則是二分搜尋。將$S$的所有元素放入$T$中，再將$T$中一半的元素放入$F$中，並將$F$中所有的元素左移1格。接著我們將$C_0$左移1格，測試是否有其他弧在$x-1$。\n若有的話，則說明與$C_0$重疊的那條弧在$F$中。令$T=F$，再將$T$中一半的元素右移1格，並將右移的元素從$F$中移除，使搜尋範圍減少一半。\n若沒有的話，則說明與$C_0$重疊的那條弧在$T-F$中。令$T=T-F$，再將$T$中一半的元素放入$F$，同時向左1格。接著將$C_0$右移1格並重複以上過程，直到$T$只剩下1條弧$C$。\n現在我們知道$C$的位置。由於之後的搜索會用到$x-1$這個位置，因此我們將$C$的右端點移至$x-2$以避免干擾。接著我們就可以將$C$移除$S$中，並重新回到移動階段，直到確認所有$n$條弧的位置。\n查詢次數分析\r我們在移動階段時，至多使用$nm-m$次右移，以找到與$C_0$重合的弧，並再至多使用$nm$次移動遍歷整個圓以找到所有的弧。此階段至多使用$2nm-m$次查詢。\n進入搜尋階段後，我們每次找到一個新的弧都會使用2次移動以將$C_0$左移再右移，共需要$2n-2$次查詢。接著每次二分搜尋都會使用$2\\log_2|T|$次查詢以將$C_0$左移再右移，因此在共計$n-1$次搜尋階段中共會耗費$2n\\log_{2} n$次查詢。\n接著在二分搜尋中，我們會使用$\\frac{n(n-1)}{2}$次查詢。\n當找到目標弧後，我們會將其左移$m$或$m+1$格，因此至多使用$(n-1)(m+1)$次移動。\n最終我們使用的總查詢次數至多為$2nm-m+2n-2+2n\\log_{2} n+\\frac{n(n-1)}{2}+(n-1)(m+1)$，由於題目限制$n\\leq 100,m\\leq 20$，將其帶入後可得出我們最多使用$12636\u0026lt;15000$次查詢。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int query(int r, int d) { int res ; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; flush; cout.flush(); cin \u0026gt;\u0026gt; res; if (res == -1) exit(1); else return res; } int n, m; int relative_pos[105]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int nm = n * m; int cur_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; unordered_set\u0026lt;int\u0026gt; S; int i; for (i = 1; i \u0026lt; n; i++) S.insert(i); int new_num; bool increased, stage = 1; // stage 0 = detection stage, 1 = moving stage while (!S.empty()) { if (stage) { new_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; if (new_num \u0026lt;= cur_num \u0026amp;\u0026amp; increased) { new_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; stage = 0; } else if (new_num \u0026gt; cur_num) increased = 1; cur_num = new_num; } else { int cur_arc = 0; unordered_set\u0026lt;int\u0026gt; T(S), F; i = 0; for (auto it = T.begin(); i \u0026lt; T.size() / 2; i++, it++) { F.insert(*it); cur_num = query(*it, -1); } while (T.size() \u0026gt; 1) { new_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; if (new_num \u0026gt;= cur_num) { T = F; int sz = F.size() / 2; i = 0; for (auto it = F.begin(); i \u0026lt; sz; i++, it++) { cur_num = query(*it, 1); F.erase(*it); } } else { for (auto it : T) { if (F.find(it) != F.end()) T.erase(it); } F.clear(); i = 0; for (auto it = T.begin(); i \u0026lt; T.size() / 2; i++, it++) { cur_num = query(*it, -1); F.insert(*it); } } cur_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; } // found the arc cur_arc = *T.begin(); if (!F.empty()) { for (i = 0; i \u0026lt; m; i++) { cur_num = query(cur_arc, -1); } relative_pos[cur_arc] = relative_pos[0] - m - 1; } else { for (i = 0; i \u0026lt;= m; i++) { cur_num = query(cur_arc, -1); } relative_pos[cur_arc] = relative_pos[0] - m - 1; } S.erase(cur_arc); stage = 1; cur_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; increased = 0; } } cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34;; for (i = 1; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; (((relative_pos[i] - relative_pos[0] + nm) % nm) + nm) % nm \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; flush; } ","date":"2024-07-21T00:00:00Z","permalink":"http://localhost:1313/p/cf1428h-rotary-laser-lock-%E9%A1%8C%E8%A7%A3/","title":"CF1428H Rotary Laser Lock 題解"},{"content":"題目\r連結: Problem - 1637H - Codeforces 前置知識: 樹狀數組 難度: 3500 題解\r本文主要參考自小粉兔的題解\n首先考慮$k=1$的情況\n當我們選取一個數$p_i$移至序列的最前方時，減少的逆序對數為$\\sum_{j=1}^{i-1}[p_j\u0026gt;p_i]-\\sum_{j=1}^{i-1}[p_{j}\u0026lt;p_{i}]$，即$p_i$ 在原先位置與其前方的元素所產生的逆序對數減去順序對數(後方的元素因將$p_i$ 移至前方後相對位置不改變，因此不會影響原序列的逆序對數)。 我們將這個數記為$d_{i}$。至於要怎麼得到$d_i$，我們可以利用樹狀數組，並同時得到原序列的逆序對數$inv$。 顯然，當$k=1$時，答案即為最大的$d_{i}$。 接著考慮$k\\ge2$的情況\n當我們依序將選取的元素$q_{1},q_{2},\\dots,q_{k}$移至前方時，每個元素分別使整個序列減少的逆序對數為選取的子序列的$d_{i}$之和，即$\\sum^k_{j=1}d_{i_{j}}$；然而當我們將子序列移至前方時，子序列內部元素彼此之間的相對位置並不會改變，而我們原先計算的$\\sum^k_{j=1}d_{i_{j}}$會記入子序列內部的影響，因此實際上減少的量需再扣除子序列內部的逆序對數減去順序對數，故實際上的原序列的逆序對數為$inv-[\\sum^k_{j=1}d_{i_{j}}-inv_{q}+(C^k_{2}-inv_{q})]$，其中$inv_{q}$為選取的子序列內部的逆序對數，$C^k_{2}-inv_{q}$為選取的子序列內部的順序對數 整理一下即可得到需最大化$\\sum^k_{j=1}d_{i_{j}}-2inv_{q}$ 這裡我們需要一個關鍵結論: 對於每個逆序對$(i, j)$(即$i\u0026lt;j且p_{i}\u0026gt;p_{j}$)，若$i$被選取在子序列中，則將$j$也選取在子序列中必使答案不更劣。我們使用反證+調整法證明:\n若存在逆序對$(i, j)$且$i$被選取而$j$未被選取，我們考慮其中$j-i$最小的那一對 由此可得到$i,j$之間不存在以下元素，否則將與$j-i$的最小性矛盾 值在$p_{j}與p_{i}$之間的元素 值大於$p_{i}$而未被選取的元素 值小於$p_{j}$而未被選取的元素 若在子序列中移除$p_{i}$並加入$p_{j}$，此時我們考慮任意元素$p_{k}$對最終逆序對數的影響: 若$k\u0026lt;i$且$p_{k}$被選取，則$p_{k}$與$p_{i},p_{j}$的相對位置無變化，貢獻為$0$ 若$k\u0026lt;i$且$p_{k}$未被選取，則只有在$p_{j}\u0026lt;p_{k}\u0026lt;p_{i}$時會有貢獻$-2$，否則為$0$ 若$k\u0026gt;j$且$p_{k}$被選取，則$p_{k}$與$p_{i},p_{j}$的相對位置無變化，貢獻為$0$ 若$k\u0026gt;j$且$p_{k}$未被選取，則只有在$p_{j}\u0026lt;p_{k}\u0026lt;p_{i}$時會有貢獻$-2$，否則為$0$ 若$i\u0026lt;k\u0026lt;j$，則只有「$p_{k}\u0026gt;p_{i}且p_{k}被選取$」或「$p_{k}\u0026lt;p_{j}且p_{k}未被選取$」時，才有貢獻$1$，否則為$-1$；然而前文已說明不存在「$p_{k}\u0026gt;p_{i}且p_{k}被選取$」或「$p_{k}\u0026lt;p_{j}且p_{k}未被選取$」的情況。 因此，若存在逆序對$(i, j)$且$i$被選取而$j$未被選取，我們可刪除$i$並加入$j$，此時答案一定不更劣。加上$(i,j)$本身從逆序對變為順序對會對答案有$-1$的貢獻，因此總變化量必為負數。 由於每次調整後子序列的下標和必增加，故調整法會在有限步內結束，證畢。 因此，前文需最大化的$\\sum^k_{j=1}d_{i_{j}}-2inv_{q}$可以改為$\\sum^k_{j=1}\\sum^n_{s=i_{j}+1}[p_{s}\u0026lt;p_{i_{j}}]$\n令$c_{i}=d_{i}-2\\sum^n_{j=i+1}[p_{j}\u0026lt;p_{i}]$，將$\\sum^k_{j=1}c_{i_{j}}$最大化即可。我們將$c$由大到小排序後逐個選取即可得到答案。\n時間複雜度為$O(n\\log n)$\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #define ll long long using namespace std; const int maxn = 500005; int n, p[maxn], c[maxn], bit[maxn]; void add(int i, int v) { while (i \u0026lt;= n) { bit[i] += v; i += i \u0026amp; -i; } } int query(int i) { int res = 0; while (i) { res += bit[i]; i -= i \u0026amp; -i; } return res; } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; memset(bit + 1, 0, sizeof(int) * n); ll inv = 0; // 首先計算原序列(k=0)的逆序對數，並順便考慮k=1的情況 for (int i = 1; i \u0026lt;= n; i++) { int a = query(p[i]);\t// 順序對 inv += i - 1 - a;\t// 逆序對 c[i] = i - 1 - 2 * a;\t// 逆序對-順序對=把i移到前面會減少的逆序對數 // 當k=1時，c[i]即為題解中的d[i] add(p[i], 1); } cout \u0026lt;\u0026lt; inv \u0026lt;\u0026lt; \u0026#39; \u0026#39;; memset(bit + 1, 0, sizeof(int) * n); for (int i = n; i \u0026gt;= 1; i--) { c[i] -= 2 * query(p[i]); add(p[i], 1); } // 對於每個k(1~n)，答案為原序列的逆序對數-(1到k的c[i]總和)-k(k-1)/2 // 其中k(k-1)/2=1+2+3+...+k-1 sort(c + 1, c + 1 + n, greater\u0026lt;\u0026gt;()); for (int i = 1; i \u0026lt;= n; i++) { inv -= c[i] + i - 1; cout \u0026lt;\u0026lt; inv \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); }\u0026gt;) ","date":"2024-07-20T00:00:00Z","permalink":"http://localhost:1313/p/cf1637h-minimize-inversions-number-%E9%A1%8C%E8%A7%A3/","title":"CF1637H Minimize Inversions Number 題解"},{"content":"學測讀書技巧分享\r前言\r我在高中的時候有研究一些讀書方法，想試試看要怎麼讀書才能最有效率，用盡量少的時間達到想要的成果(因為我很懶不喜歡讀書)。我認為比起學習課本上的知識，學習「如何學習」比較有用。以下是我試過覺得有用的讀書方法，大家可以參考一下。\n(雖然但是，我考前一天緊張到整晚沒睡，所以最後考得不太理想，以下是我的成績) 第一階段: 學習\r2個常見但沒有效率的學習法\r做筆記\r做筆記對於增強記憶其實沒什麼用，而且很耗費時間。筆記應該是當作「創作性」的用途，比如說你對於當前學習的知識有了什麼新發現，或是獨特的想法，也可能是你對於當前的概念不了解，想透過寫筆記的方式視覺化以增強理解，而不是用來幫助記憶。要記憶知識的話，稍候會介紹一個更有效率的方法。假如說你作筆記是為了編排課本上的知識以便閱讀，那其實可以直接看講義就好，大部分的講義都把知識點整理得很清楚，基本上要應付學測或段考是沒問題的。我個人是對學測範圍完全沒做筆記，把講義上的東西背熟再大量刷題找弱點就好了，這樣可以省下很多時間。\n畫重點\r畫重點有助於你在課本中更快的找到重要的知識，但對於增強學習效果其實沒什麼用，如果一開始就是讀講義的話那更是可有可無，但是如果你有這個習慣的話也不一定要改掉，讀得順手就好了。我自己是上高中之後就沒有再畫重點，有講義就直接讀講義不讀課本，因為講義都直接把重點整理好了，讀起來也比課本輕鬆很多。\n3個高效的學習法\rActive Recall\rActive Recall(主動回憶法)顧名思義就是透過回想學習的內容，進而深化其在大腦中的記憶。和作筆記跟重複讀講義不同的是，Active Recall正好與我們考試時從腦中提取記憶的過程相近，研究證實更能夠幫助我們在考試時回想出正確答案，同時也可以避免我們讀筆記跟講義時常常有的「以為自己記住了，但其實沒記住」的誤區。\n已經有很多研究測試後發現，僅使用Active Recall的人們在考試上的表現幾乎都比做筆記跟重複讀的好。而且就效率而言，Active Recall所需的時間也遠比做筆記來得少。此外，也可以透過憑記憶畫心智圖或其他方式，達到回想的效果，無論是甚麼方式，最重要的是提取記憶的過程。基本上背科(社會、生物、地科)靠這招搭配大量刷題就可以穩15級了。\n那關於Active Recall的方法，我平時會使用的主要有3種，接下來介紹給大家。\n直接回想: 在讀完一頁後，馬上回想剛剛讀到的內容，進而深化記憶。 遮關鍵字回想: 把講義讀過一遍之後，再翻一遍，然後這次把每頁需要背的東西用手遮起來，看自己能不能回想，如果不行的話就把這個東西再讀一次並試著記起來。就這樣把考試範圍翻完之後再重新讀一次（只要看記不起來的部分就好)，一直重複上面的動作直到把所有要看的東西記起來就好ㄌ。 填空回想: 如果要背的東西有很多很細，那我會以填空題的方式，把每個知識點寫成一個題目，並把要背的東西挖空，之後在反覆測試看自己對於哪個地方比較不熟悉。這個方法可以跟上一個方法進行搭配，如果是容易背的東西就用第2個方法就好，稍微瑣碎或難記的知識的再使用這個方法即可(因為寫題目很花時間)。對於學測而言，通常不會考到太細的知識，所以我當時考學測就全靠前2個方法，不過段考可能就需要用到第3種方法，以下是我高三下段考有機化學所做的填空題。 Spaced Repetition\r相信大家對於「學過的東西又忘」這件事感到相當困擾。根據艾賓浩斯遺忘曲線，我們對於一件事的記憶會隨時間衰退，如下圖所示:\n(圖片來源: Retrieval: Getting and Forgetting (Part 8 of 14) | Sense and Sensation)\n那麼要如何挽救我們辛苦一天讀書的成果呢? 很簡單，這要持續地複習就好了。透過每次複習後逐漸拉長與下一次複習的間隔，最後就可以深化成堅不可摧的記憶唷。\n(圖片來源: 淺談記憶法（二）遺忘曲線與艾賓浩斯記憶法 - SoLeisure)\n至於間隔的時間，有很多種說法。我自己使用的是1天→2天→1周→1個月。不過由於準備學測時的大量刷題本身就是一種複習與記憶提取，所以我當時是沒有去使用這個方法，只有在背單字時使用(可以參考我等等會提到的背單字法)。\n還有一些軟體有提供間隔複習的功能，例如Anki、Quizlet等等，有些人會使用這些軟體背單字，但我覺得用這個背單字效率不夠高，光是輸入就要花很多時間，但如果你原本就使用電腦學習(例如讀課本的pdf、或要記憶網路上的內容等等，這通常大學以後才比較需要)，用這些軟體的效率就會提高許多。\n我所使用的講義\r數學: 徐式分冊 物理、化學、生物、地科: 新關鍵 國文: 大滿貫、大講堂文言文15篇 很多人推薦搶救國文大作戰，但我其實不推，裡面的編排方式相較於大滿貫更不易閱讀，而且有許多瑣碎且學測不會考的知識，如果對國文沒興趣只是想應付學測的話，讀大滿貫就好了。 英文: Kuso 酷文法 地理、歷史、公民: 大滿貫 各科的一些小Tips\r數學\r這裡推薦一本書—George Polya的\u0026laquo;怎樣解題\u0026raquo;，裡面有教了許多種解題的方法，讀完之後數學能力應該會有所提升。 寫題目時抱持著「每一題一定有解」的觀念，將題目給你的線索「全部」列出來(這很重要)，再看看你可以用這些線索推敲出甚麼結果(這也很重要)，因為最終的答案一定可以靠題目給你的線索解答出來。 如果看著題目給你的線索卻還沒有頭緒，可以看答案要你求甚麼，接著在反推要怎麼樣才能求得答案所需要的條件，就這樣一步步反推，推至你已經知道的條件，如此一來就可以透過逆推法來解題。 自然\r物理、化學需要計算的部分，就用跟數學解題時類似的方式，來求得答案。相信經過選修物理、化學磨練過的大家，對於學測範圍的計算部分相當的得心應手。 其他需要記憶的部分，就透過前面提到的Active Recall法來解決。 英文\r學習一個語言最重要的是培養「語感」，而培養語感的方法就是盡量多接觸這個語言。平常可以多看一些英文影片、小說、文章之類的。小說的話我推薦Tess Gerritsen的懸疑推理小說，真的很好看.w.，不過字數有點多，一開始可以先挑字數少一點的小說看。 英文基本上把單字、片語、文法背熟就可以全對了。至於要如何有效率的背單字可以參考我之前學習歷程做的 兩個月記牢一萬五千單字.pdf\n國文\r國綜 國學常識 把古文15篇中出現的字詞解釋與讀音背熟，並熟悉他們的相近字。接著再把其他國學常識背熟即可 閱讀理解、混合題: 寫的時候先看題目問你甚麼，如此一來在閱讀時才能夠有比較清楚的方向，也更能夠記住重要的內容。 研究顯示，在閱讀時用手指或筆追蹤你所讀到的內容，可以有效提高閱讀速度以及理解力。 如果平常寫閱讀測驗正確率沒辦法達到8成的話，可以每天練習寫\u0026laquo;古今悅讀100\u0026raquo;，並找出自己錯誤的原因，等到正確率有個8、9成(扣掉粗心錯的)以後，大概1~2個禮拜寫一次閱讀測驗維持手感就好了喔。 國寫 基本上就是常看學測歷年佳作、作文比賽得獎作品或是對岸的高考滿分作文，試著內化他們所表達的東西，接著再用自己的話表達一次，看看自己寫的跟他們寫的有哪裡不同，並找出可以改進的地方。 多多練習是關鍵，可以的話盡量請老師改自己練習寫的內容，並找出不足的地方加以改進。 在開始寫之前先想好結尾會是甚麼，接著通篇保持最後的立場，不要在多個觀點間猶豫不定。拿高分的首要重點是看你能不能清楚有條理的表達自己的想法，其次才是詞藻的優美度。 社會\r基本上使用Active Recall搭配大量刷題，就可以15了喔 時間管理\r我平常會使用上課時間來自習，這樣就等於一天多了5小時左右的自習時間(扣掉一些不能自習的課)，而且這樣回家就不用讀書了。 休息很重要，不要整天都在讀書，適當休息的學習成效會比整天都在讀書要好很多。 第二階段: 刷題\r將每科的講義大概看完後，刷題就是接下來最重要的關鍵。透過大量且有效的刷題，考試時才能更加得心應手，也是區分頂標跟15級的關鍵。\n快速刷題技巧\r對於理科而言，如果你已經知道接下來怎麼算，就沒必要把整題都算完，可以直接跳下一題。如此一來，你在刷題時就會發現有很多題是一眼就知道可以直接跳過的，沒必要花費多餘的時間，至於有些比較算法不明顯的題目，只需要把式子列至你知道接下來怎麼算即可。用這個方法，大約15~30分鐘就可以刷完一張自然模擬考考卷、20~40分鐘就可以刷完一張數學考卷喔。 對於背科而言，如果題目考的是你很熟悉的範圍，那就可以直接跳過。如果你對閱讀測驗也很有把握，那也可以直接跳過。不過遇到那種題幹稍長的題目，還是建議看清楚他要問甚麼比較好。 錯題本\r顧名思義就是把寫錯的題目記錄在一個本子上，之後再重複複習。這裡可以用拍照代替，之後也比較方便把照片放到間隔複習的軟體(如Anki)上，比手抄省下很多時間。這個方法我到2023年5月才開始使用，所以準備學測時沒有用到，不過我覺得這是一個很有用的方法。\n刷題的意義\r刷題時也可以想想，和這題有關的其他知識，我是不是都記清楚了，而不是只專注在眼前題目問你的東西，不要只為了答對眼前的題目而刷題，你這題是錯是對都不是重點，重點是你從刷題的過程中學習到了甚麼，並要怎麼應用在正式考試上。 第三階段: 應試\r過程\r如果你知道眼前的題目會花你很多時間，那就先跳過去寫後面的題目，不要因為在這題卡太久而導致後面該拿的分數沒拿，並在跳題的保持平靜的心態，不要因此慌了手腳，畢竟如果這道題真的很麻煩，那大家也很可能會答錯。(但記得最後要回來寫!!!) 寫數學的順序: 單選→填充→混合→多選，因為多選通常最麻煩，放最後比較不會心態崩，至於填充跟混合的順序可以調換，如果混合很簡單的話。 一些偷吃步小技巧\r注意: 以下方法只適用於學測 / 指考等大考中心的考試，對模擬考沒有用。\n領域展開法\r以112數A單選最後一題為例\n嗯，這題一看就是很麻煩的窮舉，如果要算的話可能需要花3~5分鐘，不過當時我用了一招，5秒鐘就知道答案ㄌ。先來看看我當時的視角。\n有沒有發現，已經到了單選最後一題，卻還沒有出現過3，所以這題答案就是3(ㄏㄏ)。\n這是大考中心的命題規則，如果題目數比選項數多的話，每個選項一定會出現至少一次，我檢查了近五年的答案皆是如此。所以如果你已經寫到單選的最後一題，卻還沒出現過某個選項，那最後一題的答案9成以上就是那個選項。檢查的時候甚至不用檢查最後一題，檢查前面就好了。(不過用這個方法的時候，要確定前面都有寫對)\n如果是分科數甲的話，由於單選只有3題，所以一定不會有重複的答案，這是大考中心為了避免有人靠猜題得到較高的分數的應對措施，不過我們正好可以用這個規則來猜答案.w.。\n多選判斷法\r分科 / 指考的多選，答案不是2個選項就是3個選項(數甲是2個選項居多)，不信的話可以去大考中心官網上確認。因此，可以透過這招來加速寫題的過程，或是刪掉不確定的答案。 其他一些推薦影片\r不會寫的題目也能90%猜對的方法？ 世界冠軍：用考試讀心術 ｜ 考試讀心術 第一集\n如何快速提高考試分數？ ​ 多選題猜答案的最優數學策略\n補充: 5本有助於學習的書\r以下是我讀過，對我學習方式影響最大的5本書，在這邊推薦給大家\n大腦什麼都記得住\r這本書是由美國記憶比賽冠軍所寫，裡面介紹了許多記憶的方法，內容非常實用。\n大腦什麼都記得住！用更少的力氣記住更多的東西，四屆記憶冠軍親授的「超效率無極限記憶術」\n超速學習\r這本書對於要怎麼快速且系統性的學習一個領域提供了相當詳細的教學，如果想要學習新事物，這會是一本很有用的書籍。\n超速學習：我這樣做，一個月學會素描，一年學會四種語言，完成MIT四年課程\n大腦喜歡這樣學\r這本書把許多高效率的讀書方法大致都講過了，如果你看完這篇文章後對學習技巧感到興趣，那我建議你可以來讀這本書喔\n大腦喜歡這樣學：先認識自己的大腦，找到正確的思考路徑，就能專注、不拖延，提高記憶力，學會如何學習(二版)\n怎樣解題\r這本書以許多的面向，講述了各種解題的策略與技巧。如果你想要增強自己的解題能力，這本書應該會有所幫助。\n怎樣解題\n刻意練習\r這本書詳細的講述了要在一個領域變成專家，比起天賦更重要的是訓練的方式。透過這本書教的練習方式，你也可以達成原先所認為不可能的事，取得驚人的成就喔。\n刻意練習：原創者全面解析，比天賦更關鍵的學習法\n後記\r每個人適合的讀書方法不盡相同，如果你覺得我的讀書方法對你沒什麼用，那也可以試著找找看對自己最有效的讀書方式喔。那就祝各位學弟妹考試順利，學測就上!\n還有對於某些科系而言，二階才是重點，大家記得好好準備二階考古題或是口試喔~\n","date":"2023-10-15T00:00:00Z","image":"http://localhost:1313/p/%E5%AD%B8%E6%B8%AC%E8%AE%80%E6%9B%B8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/b_hu7404989912241337256.jpg","permalink":"http://localhost:1313/p/%E5%AD%B8%E6%B8%AC%E8%AE%80%E6%9B%B8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/","title":"學測讀書技巧分享"}]