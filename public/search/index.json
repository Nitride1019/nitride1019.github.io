[{"content":"題目\r連結: Problem - 1178H - Codeforces 難度: 3500 前置知識: 二分搜尋、最小費用最大流 題解\r本題解主要參考自CF1178H Stock Exchange - ✡smy✡ - 博客园 (cnblogs.com)\n這題等價於尋找一個$[1,n]$和$[n+1,2n]$之間的二分圖匹配，但是匹配的邊會隨著$t$的變化而改變。\n注意到如果一組合法的方案在$t$時刻結束，那麼一定存在一種交換次數不劣於當前方案的方案，使得所有交換都發生在時刻$0$或時刻$t$。\n證明: 考慮一組匹配$i\\to j$\n如果在時刻$0$或時刻$t$，$i$的價格$\\geq$$j$的價格，就可以使用一次交換解決。 否則我們需要在中途換成其他元素，這個元素一定滿足其在時刻$0$的價格$\\leq$$i$的價格，且在時刻$t$的價格$\\geq$$j$的價格。 考慮第一個問題，我們先二分搜尋結束的時間$t$，並進行二分圖匹配確認時間$t$是否合法。\n把所有元素按照時刻$0$的價格由小到大排序，然後$[1,n]$的元素使用貪婪法，選擇在時刻$0$價格不超過它且時刻$t$價格最大的股票。接著開始將所有元素按照時刻$t$的價格由小到大排序，並將$[1,n]$一一對應$[n + 1, 2n]$，若其中一個失配則代表此次二分的時間$t$不合法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool check(int t) { for (int i = 1; i \u0026lt;= 2 * n; i++) ord1[i] = ord2[i] = i; sort(ord1 + 1, ord1 + 2 * n + 1, [\u0026amp;](int x, int y) { if (b[x] == b[y]) return k[x] \u0026gt; k[y]; return b[x] \u0026lt; b[y]; }); ll maxy = 0; for (int i = 1; i \u0026lt;= 2 * n; i++) { maxy = max(maxy, k[ord1[i]] * t + b[ord1[i]]); if (ord1[i] \u0026lt;= n) pos[ord1[i]] = maxy; } sort(pos + 1, pos + 1 + n); sort(ord2 + n + 1, ord2 + 2 * n + 1, [\u0026amp;](int x, int y) { return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); for (int i = 1; i \u0026lt;= n; i++) { if (pos[i] \u0026lt; k[ord2[i + n]] * t + b[ord2[i + n]]) return 0; } return 1; } 考慮第二個問題，我們使用最小費用最大流，並連結以下的邊:\n由源點向$[1,n]$連一條容量為$1$，費用為$0$的邊； 由$[n+1,2n]$向匯點連一條容量為$1$，費用為$0$的邊。 如果$i$可以在時刻$0$換成$j$，就在左邊連$i\\to j$，費用為$1$的邊； 如果$i$可以在時刻$t$換成$j$，就在右邊連$i\\to j$，費用為$1$的的邊。 但是，這題的空間限制不允許我們這麼做。注意到若存在邊$i\\to j$，則代表$i$在該時刻的價格$\\geq j$的價格。因此我們可以按照價格由小往大掃，並將所有點向其前面的點連邊即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void solve(int t) { S = ++tim; T = ++tim; for (int i = 1; i \u0026lt;= 2 * n; i++) { in[i] = ++tim; out[i] = ++tim; if (i \u0026lt;= n) add(S, in[i], 1, 0); else add(out[i], T, 1, 0); add(in[i], out[i], inf, 0); } sum[1] = in[ord1[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], in[ord1[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(in[ord1[i]], sum[i - 1], inf, 1); for (int i = 1; i \u0026lt;= 2 * n; i++) ord2[i] = i; sort(ord2 + 1, ord2 + 1 + 2 * n, [\u0026amp;](int x, int y) { if (k[x] * t + b[x] == k[y] * t + b[y]) return x \u0026gt; y; return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); sum[1] = out[ord2[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], out[ord2[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(out[ord2[i]], sum[i - 1], inf, 1); mcmf(); } 完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 100005, inf = 0x3f3f3f3f; int n, S, T, tim, cnt, res; int in[maxn], out[maxn], id[maxn], head[maxn], dis[maxn], last[maxn], from[maxn]; int ord1[maxn], ord2[maxn], sum[maxn]; queue\u0026lt;int\u0026gt; q; ll k[maxn], b[maxn], pos[maxn]; bool vis[maxn]; struct Edge { int nxt, to, w, c; } edge[2 * maxn]; void add(int x, int y, int w, int c) { edge[++cnt] = {head[x], y, w, c}; head[x] = cnt; edge[++cnt] = {head[y], x, 0, -c}; head[y] = cnt; } bool spfa() { memset(dis, inf, sizeof(int) * (tim + 1)); dis[S] = 0; q.push(S); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = edge[i].nxt) { int to = edge[i].to; if (dis[to] \u0026gt; dis[u] + edge[i].c \u0026amp;\u0026amp; edge[i].w) { dis[to] = dis[u] + edge[i].c; from[to] = u, last[to] = i; if (!vis[to]) { q.push(to); vis[to] = 1; } } } } return dis[T] != inf; } void mcmf() { while (spfa()) { res += dis[T]; int u = T; while (u != S) { edge[last[u]].w--; edge[((last[u] - 1) ^ 1) + 1].w++; u = from[u]; } } } bool check(int t) { for (int i = 1; i \u0026lt;= 2 * n; i++) ord1[i] = ord2[i] = i; sort(ord1 + 1, ord1 + 2 * n + 1, [\u0026amp;](int x, int y) { if (b[x] == b[y]) return k[x] \u0026gt; k[y]; return b[x] \u0026lt; b[y]; }); ll maxy = 0; for (int i = 1; i \u0026lt;= 2 * n; i++) { maxy = max(maxy, k[ord1[i]] * t + b[ord1[i]]); if (ord1[i] \u0026lt;= n) pos[ord1[i]] = maxy; } sort(pos + 1, pos + 1 + n); sort(ord2 + n + 1, ord2 + 2 * n + 1, [\u0026amp;](int x, int y) { return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); for (int i = 1; i \u0026lt;= n; i++) { if (pos[i] \u0026lt; k[ord2[i + n]] * t + b[ord2[i + n]]) return 0; } return 1; } void solve(int t) { S = ++tim; T = ++tim; for (int i = 1; i \u0026lt;= 2 * n; i++) { in[i] = ++tim; out[i] = ++tim; if (i \u0026lt;= n) add(S, in[i], 1, 0); else add(out[i], T, 1, 0); add(in[i], out[i], inf, 0); } sum[1] = in[ord1[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], in[ord1[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(in[ord1[i]], sum[i - 1], inf, 1); for (int i = 1; i \u0026lt;= 2 * n; i++) ord2[i] = i; sort(ord2 + 1, ord2 + 1 + 2 * n, [\u0026amp;](int x, int y) { if (k[x] * t + b[x] == k[y] * t + b[y]) return x \u0026gt; y; return k[x] * t + b[x] \u0026lt; k[y] * t + b[y]; }); sum[1] = out[ord2[1]]; for (int i = 2; i \u0026lt;= 2 * n; i++) { sum[i] = ++tim; add(sum[i], sum[i - 1], inf, 0); add(sum[i], out[ord2[i]], inf, 0); } for (int i = 2; i \u0026lt;= 2 * n; i++) add(out[ord2[i]], sum[i - 1], inf, 1); mcmf(); } int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2 * n; i++) cin \u0026gt;\u0026gt; k[i] \u0026gt;\u0026gt; b[i]; int l = 0, r = inf; while (l + 1 \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } if (l == inf) { cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; return 0; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39; \u0026#39;; solve(l); cout \u0026lt;\u0026lt; res; } ","date":"2024-08-24T00:00:00Z","permalink":"http://localhost:1313/p/cf1178h-stock-exchange-%E9%A1%8C%E8%A7%A3/","title":"CF1178H Stock Exchange 題解"},{"content":"題目\r連結: Problem - 1158F - Codeforces 前置知識: Bitmask DP 難度: 3500 題解\r本題解主要參考自官方題解。\n首先，定義$l_{1},l_{2},\\dots l_{p}$為，在$a[l_{i}+1\\dots l_{i+1}]$中，$[1,c]$中的數字均有出現過，且$a_{l_{i+1}}$恰好出現過一次的下標。稱$a[l_{i}+1\\dots l_{i+1}]$為critical array。\n由此，若求的出$l_{1},l_{2},\\dots l_{p}$，則可得出$a$的密度$\\geq p$。\n注意到由於$l_{i+1}-l_{i}+1\\geq c$，因此長度為$n$的陣列$a$其密度必$\\leq k=\\frac{n}{c}$。\n接著定義$dp[t][i]$為$a[1\\dots i]$中「剛好可以分成$t$個critical array」的子序列的數量。\n此時我們令$f[t]$為$a$中密度$\\geq t$的子序列的數量，得出$f[t]=\\sum^n_{i=1}(dp[t][i]\\cdot 2^{n-i})$，並可藉此求得答案$res[t]=f[t+1]-f[t]$。\n至於要如何求出$dp$，這裡有$2$個方法:\n第$1$個方法可在$O(n^2k)=O\\left( \\frac{n^3}{c} \\right)$的時間內完成。\n令$num[i][j]$為$a[i\\dots j]$中$a_{j}$僅出現過一次的子序列數，$cnt[x][i][j]$為$x$在$a[i\\dots j]$中出現過的次數，則可以得到$num[i][j]=\\Pi_{x=1}^c(2^{cnt[x][i][j]}-1)$，因為$x$在$a[i\\dots j]$共可以產生$2^{cnt[x][i][j]}$種子序列，且至少$x$至少要出現一次，故減去$1$。\n於是就可得到$dp[t][i]$的轉移式: $$dp[t][i]=\\sum_{j=0}^{i-1}(dp[t-1][j]\\cdot num[j+1][i])$$\n第$2$個方法可在$O\\left( nk2^c \\right)=O\\left( \\frac{n^3}{\\log n} \\right)$時間內完成。\n令$u[i][t][mask]$為$a[1\\dots i]$中先選取好$t$個critical array，且在最後一個critical array的結尾到$i$之間已有$mask$的元素被選取的子序列數。\n則可以得到$dp[t][i]=u[i-1][t-1][2^c-i-2^{a_{i}}]$。\n接著我們考慮$u$的轉移式:\n$$u[i][t][mask]=\\begin{cases}u[i-1][t][mask]\u0026amp;\\text{if }a_{i}\\text{ is not in mask}\\newline2u[i-1][t][mask]+u[i-1][t][mask-2^{a_{i}}]\u0026amp;\\text{if }a_{i}\\text{ is in mask}\\end{cases}$$\n由於$u[i][t][mask]$的轉移只會用到$u[i-1]$，故可以節省記憶體空間，使用滾動陣列。\n至於當$mask=0$時，$u[i][t][0]=u[i-1][t][0]+dp[t][i]$，即「加入$a_{i}$前就已經完成$t$個critical array」加上「加入$a_{i}$後剛好完成第$t$個critical array」的子序列數。\n以上便完成了兩種時間複雜的的解法。在$c\u0026gt;\\log_{2}n$時，$\\frac{n^3}{c}\u0026lt; \\frac{n^3}{\\log_{2}n}$，故採用第一種解法；反之則採用第二種解法。如此一來便可通過此題。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 3005; const int mod = 998244353; const ll mod2 = (ll)mod * (ll)mod; void add(int \u0026amp;a, int b) { a += b; if (a \u0026gt;= mod) a -= mod; } int qpow(int a, int b) { int res = 1; while (b) { if (b \u0026amp; 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } int n, c, a[maxn]; int cnt[maxn][maxn]; // cnt[i][x + 1] = i在a[1...x]中出現過的次數 int pw[maxn], inv[maxn]; int k, used_cnt; int dp[maxn][maxn], num[maxn][maxn]; void solve_n2k() { for (int i = 0; i \u0026lt;= n; i++) inv[i] = qpow(pw[i] - 1, mod - 2); for (int i = 0; i \u0026lt; n; i++) { int cur = 1; used_cnt = c; for (int j = i; j \u0026lt; n; j++) { if (cnt[a[j]][i] == cnt[a[j]][j]) used_cnt--; else cur = 1ll * cur * inv[cnt[a[j]][j] - cnt[a[j]][i]] % mod; if (used_cnt != 0) num[i][j] = 0; else num[i][j] = cur; cur = 1ll * cur * (pw[cnt[a[j]][j] - cnt[a[j]][i] + 1] - 1) % mod; } } dp[0][0] = 1; for (int t = 1; t \u0026lt;= k; t++) { for (int i = t * c - 1; i \u0026lt; n; i++) { ll sum = 0; for (int j = i; j \u0026gt;= (t - 1) * c; j--) { sum += 1ll * dp[t - 1][j] * num[j][i]; if (sum \u0026gt;= mod2) sum -= mod2; } dp[t][i + 1] = sum % mod; } } } int u[maxn][1 \u0026lt;\u0026lt; 10]; void solve_nk2powc() { dp[0][0] = 1; u[0][0] = 1; for (int i = 0; i \u0026lt; n; i++) { for (int t = 1; t \u0026lt;= k; t++) dp[t][i + 1] = u[t - 1][((1 \u0026lt;\u0026lt; c) - 1) ^ (1 \u0026lt;\u0026lt; a[i])]; int maxt = min(k - 1, (i / c)); for (int mask = (1 \u0026lt;\u0026lt; c) - 1; mask \u0026gt;= 0; mask--) { if ((mask \u0026gt;\u0026gt; a[i]) \u0026amp; 1) { for (int t = 0; t \u0026lt;= maxt; t++) { add(u[t][mask], u[t][mask]); add(u[t][mask], u[t][mask ^ (1 \u0026lt;\u0026lt; a[i])]); } } } for (int t = 0; t \u0026lt; k; t++) add(u[t][0], dp[t][i + 1]); } } int res[maxn]; bool used[maxn]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i]--; } for (int i = 0; i \u0026lt; c; i++) { cnt[i][0] = 0; for (int x = 0; x \u0026lt; n; x++) { cnt[i][x + 1] = cnt[i][x]; if (a[x] == i) cnt[i][x + 1]++; } } pw[0] = 1; for (int i = 0; i \u0026lt; n; i++) { pw[i + 1] = pw[i] + pw[i]; if (pw[i + 1] \u0026gt;= mod) pw[i + 1] -= mod; } for (int i = 0; i \u0026lt; n; i++) { if (!used[a[i]]) { used[a[i]] = 1; used_cnt++; } if (used_cnt == c) { used_cnt = 0; for (int i = 0; i \u0026lt; c; i++) used[i] = 0; k++; } } if (c \u0026lt;= 10) solve_nk2powc(); else solve_n2k(); for (int i = 0; i \u0026lt;= k; i++) { for (int j = 0; j \u0026lt;= n; j++) { add(res[i], 1ll * dp[i][j] * pw[n - j] % mod); } } for (int i = 0; i \u0026lt; n; i++) { res[i] -= res[i + 1]; if (res[i] \u0026lt; 0) res[i] += mod; } res[0]--; if (res[0] \u0026lt; 0) res[0] += mod; for (int i = 0; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } ","date":"2024-08-10T00:00:00Z","permalink":"http://localhost:1313/p/cf1158f-density-of-subarrays-%E9%A1%8C%E8%A7%A3/","title":"CF1158F Density of Subarrays 題解"},{"content":"題目\r連結: Problem - 1033G - Codeforces 前置知識: 無 難度: 3500 題解\r本題解主要參考自zsc9852462的題解。本文將我當時看這篇題解有理解困難的地方更加詳細的說明，以及改正原文的一些小錯誤。\n首先，我們發現Alice必勝與Bob必勝本質是相同的，皆為$\\frac{m^2-w_{f}-w_{s}}{2}$，因此只須考慮先手必勝跟後手必勝的情況。\n容易看出將$v_i$對$(a+b)$取模並不會影響結果，因此我們令$w_{i}=v_{i}\\mod(a+b)$。\n假設$a\\leq b$，則$w_i$只可能會是以下4種情況:\n$0\\leq w_{i}\u0026lt;a$: 該堆無法被任何人取 $a\\leq w_{i}\u0026lt;b$: Alice取完會變情況1，Bob不能取。若$a=b$則不會有此情況。 $b\\leq w_{i}\u0026lt;2a$: Alice或Bob取完都會變情況1。若$b\\geq 2a$則不會有此情況。 $max(2a,b)\\leq w_{i}\u0026lt;x+y$: Alice取完會變情況2，Bob取完會變情況1。若$a=b$則不會有此情況。 接著對各種情況進行討論。另$c_{i}$為第$i$種類型的堆的數量:\n$c_{2}\\geq 1$: Alice必勝 $c_{2}=0$ $c_{4}\\geq 2$: Alice必勝 $c_{4}=1$: $c_{3}$為奇數: Alice必勝 $c_{3}$為偶數: 先手必勝 $c_{4}=0$: $c_{3}$為奇數: Alice必勝 $c_{3}$為偶數: 後手必勝 我們只關心先手必勝跟後手必勝，將其條件整理如下:\n先手必勝: $c_{2}=0$且$c_{4}=1$且$c_{3}$為偶數。 後手必勝: $c_{2}=0$且$c_{4}=0$且$c_{3}$為偶數。 將以上條件轉換為數學式:\n先手必勝: $\\forall w_{i},w_{i}\\notin[a,b),\\sum[w_{i}\\geq max(2a,b)]=1,\\sum[w_{i}\\geq b]\\mod 1=1$ 後手必勝: $\\forall w_{i},w_{i}\\notin[a,b),\\sum[w_{i}\\geq max(2a,b)]=0,\\sum[w_{i}\\geq b]\\mod 1=0$ 我們可以枚舉$sum=a+b$，對$v_{i}$取模後排序$w_{i}$。因為在先手必勝或後手必勝的情況下$\\forall w_{i},w_{i}\\notin[a,b)$，故存在$i$使得$w_{i}\u0026lt;a,b\\leq w_{i+1}$。我們接著枚舉符合此條件的$w_{i}$。\n先手必勝時$\\sum[w_{i}\\geq max(2a,b)]=1$。由於我們已將$w_{i}$排序過，故前式等價於$max(2a,b)\u0026gt;w_{n-1}$。\n我們令$w_{n}=sum-1$，即模$sum$下的最大值。如果$b\u0026gt;2a$，代表$w_{n-1}\u0026lt;b\\leq w_{n}\\implies w_{n-1}\u0026lt;a\\leq w_{n}$。因為$b\u0026gt;2a\u0026gt;a$，故也可推得$w_{n-1}\u0026lt;2a\\leq w_{n}$。\n把$a\\leq b$的條件解除，由上面推導我們可得出$a,b\\in[l,r]$，其中$l=max\\left( w_{i},\\left\\lfloor \\frac{w_{n-1}}{2} \\right\\rfloor \\right)+1,r=min(w_{i+1},m)$。再由$b=sum-a$我們可以得到$a\\in[max(l,sum-r),min(r,sum-l)]$。\n由於一個$a$對應一個$b$，所以$min(r,sum-l)-max(l,sum-r)+1$就是當時枚舉的$sum$對答案的貢獻。\n後手同理。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int maxn = 105; ll n, m; ll v[maxn], w[maxn]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; ll wf = 0, ws = 0; for (int sum = 2; sum \u0026lt;= 2 * m; sum++) { for (int i = 1; i \u0026lt;= n; i++) w[i] = v[i] % sum; sort(w + 1, w + 1 + n); w[n + 1] = sum - 1;\t// 插入最大值 for (int i = 0; i \u0026lt;= n; i++) {\t// w[i] \u0026lt; a, b \u0026lt;= w[i + 1] if ((n - i) \u0026amp; 1) {\t// w[i] \u0026gt;= b的數量為奇數，計算先手必勝 ll l = max(w[i], w[n - 1] / 2) + 1, r = min(w[i + 1], m); wf += max(0ll, min(r, sum - l) - max(l, sum - r) + 1); } else {\t// w[i] \u0026gt;= b的數量為偶數，計算後手必勝 ll l = max(w[i], w[n] / 2) + 1, r = min(w[i + 1], m); ws += max(0ll, min(r, sum - l) - max(l, sum - r) + 1); } } } cout \u0026lt;\u0026lt; (m * m - wf - ws) / 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (m * m - wf - ws) / 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; wf \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ws; } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1033g-chip-games-%E9%A1%8C%E8%A7%A3/","title":"CF1033G Chip Games 題解"},{"content":"題目\r連結: Problem - 1835E - Codeforces 前置知識: DP 難度: 3500 題解\r本題解主要參考自tcz_wk在洛谷上的題解\n首先，注意到當一個字符在序列中不是第一次出現，由於我們已在第1次輸入該字符時知道它的鍵位，因此只需再按1次該鍵即可。故我們只需關心這個序列中出現了多少不同的數。\n設$C$為序列中出現的不同的字符的集合，大小為$A$；$X$為序列中並未出現，但是鍵盤上有該字符的集合，大小為$B$(等於$m-A$)。\n接著根據我們在輸入過程中可能會有的狀況，設立三個$dp$狀態:\n$f[i][j]$表示已經知道backspace在哪裡，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 $g[i][j]$表示尚未知道backspace在哪裡，目前螢幕上顯示的序列$並非$目標序列的前綴，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 $h[i][j]$表示尚未知道backspace在哪裡，目前螢幕上顯示的序列為目標序列的前綴，且剩$i$個$C$中的字符尚未知道位置, $j$個$X$中的字符尚未知道位置，此狀態下輸入完成所需的期望步數。 接下來我們考慮$f[i][j]$的轉移，共3種情況:\n有$\\frac{1}{i+j}$的機率按下正確的字符，貢獻為$f[i - 1][j] + 1$ 有$\\frac{i-1}{i+j}$的機率按下錯誤的字符，且該字符在$C$中，貢獻為$f[i-1][j]+3$。加3是因為按下這個鍵後，要按backspace把它刪掉，等之後再遇到時還要再按一次。 有$\\frac{j}{i+j}$的機率按下錯誤的字符，且該字符在$X$中，貢獻為$f[i][j-1]+2$ 考慮$g[i][j]$的轉移，共3種情況:\n有$\\frac{1}{i+j+1}$的機率按下backspace，貢獻為$f[i][j] + 1$ 有$\\frac{i}{i+j+1}$的機率按下$C$中的鍵，貢獻為$g[i-1][j]+3$。加$3$的理由跟$f$中提到的一樣。 有$\\frac{j}{i+j+1}$的機率按下$X$中的鍵，貢獻為$g[i][j-1]+2$ 考慮$h[i][j]$的轉移，共4種情況:\n有$\\frac{1}{i+j+1}$的機率按下正確的字符，貢獻為$h[i-1][j]+1$ 有$\\frac{i-1}{i+j+1}$的機率按下不是正確但是位於$C$中的字符，貢獻為$g[i-1][j]+3$ 有$\\frac{j}{i+j+1}$的機率按下$X$中的字符，貢獻為$g[i][j-1]+2$ 有$\\frac{1}{i+j+1}$的機率按下backspace，貢獻為$f[i][j]+2$ 最後考慮第$1$步對結果的貢獻。\n有$\\frac{1}{m+1}$的機率按下backspace，貢獻為$f[a][b]+1$ 有$\\frac{1}{m+1}$的機率按下正確的字符，貢獻為$h[a-1][b]+1$ 有$\\frac{a-1}{m+1}$的機率按下錯誤的字符，且該字符在C中(即未來會出現)，貢獻為$g[a-1][b]+3$ 有$\\frac{1}{m+1}$的機率按下錯誤的字符，且該字符在$X$中(即未來不會出現)，貢獻為$g[a][b-1]+2$ 記得將答案初始設為$n-a$(即目標序列中不是第一次出現的字符的數量)，因為我們在轉移中不會考慮其對答案的貢獻。\n時間複雜度為$O(n^2)$。\n個人認為這題難度相較於其他$3500$分的題目，算是簡單了不少，因為本菜雞在看其他$3500$難度的題目時，常常連題解也看不懂.w.\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxm = 1005; const int mod = 1e9 + 7; int n, m; int inv[maxm]; int f[maxm][maxm], g[maxm][maxm], h[maxm][maxm]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; inv[0] = inv[1] = 1; unordered_set\u0026lt;int\u0026gt; s; for (int i = 2; i \u0026lt;= m + 1; i++) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; for (int i = 1, x; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; s.insert(x); } int a = s.size(), b = m - a; for (int i = 1; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { f[i][j] = 1ll * (i - 1) * inv[i + j] % mod * (f[i - 1][j] + 3) % mod; f[i][j] = (f[i][j] + 1ll * inv[i + j] * (f[i - 1][j] + 1)) % mod; if (j) f[i][j] = (f[i][j] + 1ll * inv[i + j] * j % mod * (f[i][j - 1] + 2)) % mod; } } for (int i = 0; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { g[i][j] = 1ll * inv[i + j + 1] * f[i][j] % mod; if (i) g[i][j] = (g[i][j] + 1ll * inv[i + j + 1] * i % mod * (g[i - 1][j] + 3)) % mod; if (j) g[i][j] = (g[i][j] + 1ll * inv[i + j + 1] * j % mod * (g[i][j - 1] + 2)) % mod; } } for (int i = 1; i \u0026lt;= a; i++) { for (int j = 0; j \u0026lt;= b; j++) { h[i][j] = 1ll * inv[i + j + 1] * (h[i - 1][j] + 1) % mod; h[i][j] = (h[i][j] + 1ll * (i - 1) * inv[i + j + 1] % mod * (g[i - 1][j] + 3)) % mod; h[i][j] = (h[i][j] + 1ll * inv[i + j + 1] * (f[i][j] + 2)) % mod; if (j) h[i][j] = (h[i][j] + 1ll * j * inv[i + j + 1] % mod * (g[i][j - 1] + 2)) % mod; } } int res = n - a; res = (res + 1ll * inv[m + 1] * (f[a][b] + 1)) % mod; res = (res + 1ll * inv[m + 1] * (h[a - 1][b] + 1)) % mod; res = (res + 1ll * inv[m + 1] * (a - 1) % mod * (g[a - 1][b] + 3)) % mod; res = (res + 1ll * inv[m + 1] * b % mod * (g[a][b - 1] + 2)) % mod; cout \u0026lt;\u0026lt; res; } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1835e-old-mobile-%E9%A1%8C%E8%A7%A3/","title":"CF1835E Old Mobile 題解"},{"content":"題目\r連結: Problem - 1994H - Codeforces 前置知識: 無 難度: 3500 題解\r本題解主要參考自大佬$jiangly$的程式碼。\n本題限制$p + 1 \u0026lt; m$，所以我們可以透過查詢\u0026quot;$aa$\u0026ldquo;得到$p + 1$的值。\n接著我們另$s=$\u0026quot;$zzzzzzzzzz$\u0026quot;(10個$z$)，並查詢$s$得到$hash=(26+26p^1+26p^2+\\dots+26p^9)\\mod m$。令其值為$a_{0}+a_{1}p+a_{2}p^2+\\dots+cp^i$。將$c$與$i$記錄下來。\n此時我們知道$cp^i\u0026lt;m,(c+1)p^i\\geq m$，若$c\u0026lt;25$，則我們令$s$的第$i$個字符為$z-(c+1)$ (使用ASCII編碼)。接著再查詢更新過的$s$，得到$new_hash=(26+26p+26p^2+\\dots+(26-c-1)p^i+\\dots+26p^9)\\mod m$。\n將$new_hash$減去$hash$得到$-(c+1)p^i\\mod m$。由$(c+1)p^i\\geq m$可得知$-(c+1)p^i\\leq m$，故$-(c+1)p^i\\mod m=-(c+1)p^i+m$。將其加上$(c+1)p^i$即可得到$m$的值。\n若$c=25$，則我們令$s$的第$i+1$個字符為$z-1=y$。接著查詢更新過的$s$，得到$new_hash=(26+26p+26p^2+\\dots+26p^i+25p^{i+1}+\\dots+26p^9)\\mod m$。將其減去$hash$得到$-p^{i+1}\\mod m=-p^{i+1}+m$，再加上$p^{i+1}$即可得到$m$的值。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; void solve() { int p; cout \u0026lt;\u0026lt; \u0026#34;? aa\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; p; p--; string s(10, \u0026#39;z\u0026#39;); int hash, c; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; hash; c = hash; int i = 0; ll pw = 1; // hash = (26 + 26p + 26p^2 + ... + 26p^9) mod m = a_0 + a_1p + a_2p^2 + ... + c*p^i // pw = p^i while (c \u0026gt;= p) { c /= p; pw *= p; i++; } if (c \u0026lt; 25) { // new_hash = (26 + 26p + 26p^2 + ... + (26 - c - 1)p^i + ... + 26p^9) mod m // pw = (c + 1)p^i // new_hash - hash = (-c - 1)p^i mod m. We know that c*p^i \u0026lt; m and (c + 1)p^i \u0026gt;= m // thus (-c - 1)p^i mod m = (-c - 1)p^i + m s[i] -= c + 1; pw *= c + 1; } else { // new_hash = (26 + 26p + 26p^2 + ... + 25p^(i+1) + ... + 26p^9) mod m // pw = p^(i + 1) s[i + 1]--; pw *= p; } // new_hash - hash = (-c - 1)p^i + m int new_hash; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cin \u0026gt;\u0026gt; new_hash; cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; new_hash + pw - hash \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); } ","date":"2024-07-28T00:00:00Z","permalink":"http://localhost:1313/p/cf1994h-fortnite-%E9%A1%8C%E8%A7%A3/","title":"CF1994H Fortnite 題解"},{"content":"題目\r連結: Problem - 1349D - Codeforces 前置知識: 高斯消元 難度: 3200 題解\r本題解主要參考自官方題解\n首先令使第$i$個人擁有全部餅乾的期望時間為$E_i$。答案$E$即為$\\sum^n_{i=1}E_{i}$。\n令$P_{i}$為遊戲結束時所有餅乾在第$i$個人手上的機率。不難得到$\\sum^n_{i=1}P_i=0$。\n此時我們稍微改變遊戲規則，令遊戲只在第$i$個人拿到所有餅乾時才結束(與原遊戲規則的差別為，$i$以外的人拿到所有餅乾時不會結束)。此時的遊戲的期望時間為$E_i\u0026rsquo;$。\n然後我們再令$C$為當某人持有全部餅乾時，將此人的餅乾全部轉移至另一個人所需的期望時間。此時我們可以得到以下等式: $$E_{x}=E_{x}\u0026rsquo;-\\sum^n_{i=1}[i\\ne x](P_{i}\\cdot C+E_{i})$$ 將其移項後即可得到:$$\\sum^n_{i=1}E_{i}=E_{x}\u0026rsquo;-C\\sum^n_{i=1}[i \\ne x]P_{i}$$ 再將上式從$x=1到n$做加總:$$n\\sum^n_{i=1}E_{i}=\\sum^n_{i=1}E_{i}\u0026rsquo;-C(n-1)\\sum^n_{i=1}P_{i}$$ 已知答案$E$為$\\sum^n_{i=1}E_{i}$，且$\\sum^n_{i=1}P_{i}=1$。故我們可將上式簡化為:$$n \\cdot E=\\sum^n_{i=1}E_{i}\u0026rsquo;-C(n-1)$$此時我們令$f_{i}$為當一個人擁有$i$個餅乾時，使此人擁有所有餅乾的期望時間，則我們可以得出$E_{i}\u0026rsquo;=f_{a_{i}},,C=f_{0}$。令$m$為總餅乾數，我們不難得出以下遞推式: $$f_{i}=\\begin{cases} 1 + \\frac{m-i}{m}\\left( \\frac{1}{n-1}f_{i+1}+\\frac{n-2}{n}f_{i} \\right)+\\frac{i}{m}f_{i-1}, \u0026amp;0\u0026lt;i\u0026lt;m \\newline 1+\\frac{1}{n-1}f_{0}+ \\frac{n-2}{n-1}f_{1}, \u0026amp;i=0 \\newline 0, \u0026amp;i=m\\end{cases}$$\n然而，我們在透過消元解以上方程式時，可能會出現主元為$0$的情況。為了避免，我們令$g_{i}=f_{i}-f_{i+1},g_{0}=0,g_{m}=0$，可以得出$f_{i}=\\sum^m_{j=i}g_{j}$。\n於是，我們可以將$f_{i}$在$0\u0026lt;i\u0026lt;m$的情況寫為:$$\\sum^m_{j=i}g_{j}=1 + \\frac{m-i}{m}\\left( \\frac{1}{n-1}\\sum^m_{j=i+1}g_{j}+\\frac{n-2}{n}\\sum^m_{j=i}g_{j} \\right)+\\frac{i}{m}\\sum^m_{j=i-1}g_{j}$$ 相消之後可以得到:$$g_{i}=1+\\frac{(m-i)(n-2)}{m(n-1)}g_{i}+\\frac{i}{m}(g_{i}+g_{i-1})$$ $$g_{i}=\\frac{m(n-1)+i(n-1)g_{i-1}}{m-i}$$ 這樣就不會產生主元為$0$的情況了。\n這題還有用鞅與停時定理的解法，有興趣的人可以上網找找看。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const int M = 998244353; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % M; a = a * a % M; b \u0026gt;\u0026gt;= 1; } return res; } const int maxn = 100005, maxm = 300005; int n, m; int a[maxn]; ll res[maxm]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; m += a[i]; } ll invm = qpow(m, M - 2), invn1 = qpow(n - 1, M - 2); for (int i = m; i \u0026gt;= 1; i--) { ll k1 = i * invm % M * invn1 % M, k2 = (m - i) * invm % M; res[i] = (k2 * res[i + 1] + 1) % M * qpow(k1, M - 2) % M; } for (int i = 1; i \u0026lt;= m; i++) res[i] = (res[i] + res[i - 1]) % M; ll s = 0; for (int i = 1; i \u0026lt;= n; i++) s = (s + res[m - a[i]]) % M; s = (s + M - res[m] * (n - 1) % M) % M; cout \u0026lt;\u0026lt; s * qpow(n, M - 2) % M; } ","date":"2024-07-22T00:00:00Z","permalink":"http://localhost:1313/p/cf1349d-slime-and-biscuits-%E9%A1%8C%E8%A7%A3/","title":"CF1349D Slime and Biscuits 題解"},{"content":"題目\r連結: Problem - 1428H - Codeforces 前置知識: 二分搜尋 難度: 3500 題解\r本題解主要參考自官方題解\n為了方便起見，我們將把弧順時針旋轉的操作改為將其移至右邊，逆時針旋轉的操作改為將其移至左邊，並以$C_0$代表第0條弧。\n本演算法分為兩個階段: 移動階段與搜尋階段。\n首先要得出一個重要的結論: 當我們將$C_0$右移時，若未被阻擋的光線$a$較原先增加，則說明$C_0$原先左端點的位置並無其他圓弧。然後我們繼續將$C_0$向右移動，若在一次移動的過程中$a$沒有增加，則說明在這次移動前$C_0$與其他的弧完全重合。此即為移動階段。\n此時我們將$C_0$左移1格(即回至與其他弧重疊的位置)，並令其左端點為$x$。\n接著進入搜尋階段，開始搜尋與$C_0$重疊的那條弧。令$S$為尚未知道位置的弧(一開始為弧$1到n-1$)的集合，並令$T$為所有可能與$C_0$重疊的弧的集合，以及$F$為待會要左移以測試是否與$C_0$重疊的弧的集合。\n至於搜尋的方法則是二分搜尋。將$S$的所有元素放入$T$中，再將$T$中一半的元素放入$F$中，並將$F$中所有的元素左移1格。接著我們將$C_0$左移1格，測試是否有其他弧在$x-1$。\n若有的話，則說明與$C_0$重疊的那條弧在$F$中。令$T=F$，再將$T$中一半的元素右移1格，並將右移的元素從$F$中移除，使搜尋範圍減少一半。\n若沒有的話，則說明與$C_0$重疊的那條弧在$T-F$中。令$T=T-F$，再將$T$中一半的元素放入$F$，同時向左1格。接著將$C_0$右移1格並重複以上過程，直到$T$只剩下1條弧$C$。\n現在我們知道$C$的位置。由於之後的搜索會用到$x-1$這個位置，因此我們將$C$的右端點移至$x-2$以避免干擾。接著我們就可以將$C$移除$S$中，並重新回到移動階段，直到確認所有$n$條弧的位置。\n查詢次數分析\r我們在移動階段時，至多使用$nm-m$次右移，以找到與$C_0$重合的弧，並再至多使用$nm$次移動遍歷整個圓以找到所有的弧。此階段至多使用$2nm-m$次查詢。\n進入搜尋階段後，我們每次找到一個新的弧都會使用2次移動以將$C_0$左移再右移，共需要$2n-2$次查詢。接著每次二分搜尋都會使用$2\\log_2|T|$次查詢以將$C_0$左移再右移，因此在共計$n-1$次搜尋階段中共會耗費$2n\\log_{2} n$次查詢。\n接著在二分搜尋中，我們會使用$\\frac{n(n-1)}{2}$次查詢。\n當找到目標弧後，我們會將其左移$m$或$m+1$格，因此至多使用$(n-1)(m+1)$次移動。\n最終我們使用的總查詢次數至多為$2nm-m+2n-2+2n\\log_{2} n+\\frac{n(n-1)}{2}+(n-1)(m+1)$，由於題目限制$n\\leq 100,m\\leq 20$，將其帶入後可得出我們最多使用$12636\u0026lt;15000$次查詢。\n完整程式碼\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int query(int r, int d) { int res ; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; flush; cout.flush(); cin \u0026gt;\u0026gt; res; if (res == -1) exit(1); else return res; } int n, m; int relative_pos[105]; int main() { cin.tie(0)-\u0026gt;sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int nm = n * m; int cur_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; unordered_set\u0026lt;int\u0026gt; S; int i; for (i = 1; i \u0026lt; n; i++) S.insert(i); int new_num; bool increased, stage = 1; // stage 0 = detection stage, 1 = moving stage while (!S.empty()) { if (stage) { new_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; if (new_num \u0026lt;= cur_num \u0026amp;\u0026amp; increased) { new_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; stage = 0; } else if (new_num \u0026gt; cur_num) increased = 1; cur_num = new_num; } else { int cur_arc = 0; unordered_set\u0026lt;int\u0026gt; T(S), F; i = 0; for (auto it = T.begin(); i \u0026lt; T.size() / 2; i++, it++) { F.insert(*it); cur_num = query(*it, -1); } while (T.size() \u0026gt; 1) { new_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; if (new_num \u0026gt;= cur_num) { T = F; int sz = F.size() / 2; i = 0; for (auto it = F.begin(); i \u0026lt; sz; i++, it++) { cur_num = query(*it, 1); F.erase(*it); } } else { for (auto it : T) { if (F.find(it) != F.end()) T.erase(it); } F.clear(); i = 0; for (auto it = T.begin(); i \u0026lt; T.size() / 2; i++, it++) { cur_num = query(*it, -1); F.insert(*it); } } cur_num = query(0, 1); relative_pos[0] = (relative_pos[0] + 1) % nm; } // found the arc cur_arc = *T.begin(); if (!F.empty()) { for (i = 0; i \u0026lt; m; i++) { cur_num = query(cur_arc, -1); } relative_pos[cur_arc] = relative_pos[0] - m - 1; } else { for (i = 0; i \u0026lt;= m; i++) { cur_num = query(cur_arc, -1); } relative_pos[cur_arc] = relative_pos[0] - m - 1; } S.erase(cur_arc); stage = 1; cur_num = query(0, -1); relative_pos[0] = (relative_pos[0] - 1 + nm) % nm; increased = 0; } } cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34;; for (i = 1; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; (((relative_pos[i] - relative_pos[0] + nm) % nm) + nm) % nm \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; flush; } ","date":"2024-07-21T00:00:00Z","permalink":"http://localhost:1313/p/cf1428h-rotary-laser-lock-%E9%A1%8C%E8%A7%A3/","title":"CF1428H Rotary Laser Lock 題解"},{"content":"學測讀書技巧分享\r前言\r我在高中的時候有研究一些讀書方法，想試試看要怎麼讀書才能最有效率，用盡量少的時間達到想要的成果(因為我很懶不喜歡讀書)。我認為比起學習課本上的知識，學習「如何學習」比較有用。以下是我試過覺得有用的讀書方法，大家可以參考一下。\n(雖然但是，我考前一天緊張到整晚沒睡，所以最後考得不太理想，以下是我的成績) 第一階段: 學習\r2個常見但沒有效率的學習法\r做筆記\r做筆記對於增強記憶其實沒什麼用，而且很耗費時間。筆記應該是當作「創作性」的用途，比如說你對於當前學習的知識有了什麼新發現，或是獨特的想法，也可能是你對於當前的概念不了解，想透過寫筆記的方式視覺化以增強理解，而不是用來幫助記憶。要記憶知識的話，稍候會介紹一個更有效率的方法。假如說你作筆記是為了編排課本上的知識以便閱讀，那其實可以直接看講義就好，大部分的講義都把知識點整理得很清楚，基本上要應付學測或段考是沒問題的。我個人是對學測範圍完全沒做筆記，把講義上的東西背熟再大量刷題找弱點就好了，這樣可以省下很多時間。\n畫重點\r畫重點有助於你在課本中更快的找到重要的知識，但對於增強學習效果其實沒什麼用，如果一開始就是讀講義的話那更是可有可無，但是如果你有這個習慣的話也不一定要改掉，讀得順手就好了。我自己是上高中之後就沒有再畫重點，有講義就直接讀講義不讀課本，因為講義都直接把重點整理好了，讀起來也比課本輕鬆很多。\n3個高效的學習法\rActive Recall\rActive Recall(主動回憶法)顧名思義就是透過回想學習的內容，進而深化其在大腦中的記憶。和作筆記跟重複讀講義不同的是，Active Recall正好與我們考試時從腦中提取記憶的過程相近，研究證實更能夠幫助我們在考試時回想出正確答案，同時也可以避免我們讀筆記跟講義時常常有的「以為自己記住了，但其實沒記住」的誤區。\n已經有很多研究測試後發現，僅使用Active Recall的人們在考試上的表現幾乎都比做筆記跟重複讀的好。而且就效率而言，Active Recall所需的時間也遠比做筆記來得少。此外，也可以透過憑記憶畫心智圖或其他方式，達到回想的效果，無論是甚麼方式，最重要的是提取記憶的過程。基本上背科(社會、生物、地科)靠這招搭配大量刷題就可以穩15級了。\n那關於Active Recall的方法，我平時會使用的主要有3種，接下來介紹給大家。\n直接回想: 在讀完一頁後，馬上回想剛剛讀到的內容，進而深化記憶。 遮關鍵字回想: 把講義讀過一遍之後，再翻一遍，然後這次把每頁需要背的東西用手遮起來，看自己能不能回想，如果不行的話就把這個東西再讀一次並試著記起來。就這樣把考試範圍翻完之後再重新讀一次（只要看記不起來的部分就好)，一直重複上面的動作直到把所有要看的東西記起來就好ㄌ。 填空回想: 如果要背的東西有很多很細，那我會以填空題的方式，把每個知識點寫成一個題目，並把要背的東西挖空，之後在反覆測試看自己對於哪個地方比較不熟悉。這個方法可以跟上一個方法進行搭配，如果是容易背的東西就用第2個方法就好，稍微瑣碎或難記的知識的再使用這個方法即可(因為寫題目很花時間)。對於學測而言，通常不會考到太細的知識，所以我當時考學測就全靠前2個方法，不過段考可能就需要用到第3種方法，以下是我高三下段考有機化學所做的填空題。 Spaced Repetition\r相信大家對於「學過的東西又忘」這件事感到相當困擾。根據艾賓浩斯遺忘曲線，我們對於一件事的記憶會隨時間衰退，如下圖所示:\n(圖片來源: Retrieval: Getting and Forgetting (Part 8 of 14) | Sense and Sensation)\n那麼要如何挽救我們辛苦一天讀書的成果呢? 很簡單，這要持續地複習就好了。透過每次複習後逐漸拉長與下一次複習的間隔，最後就可以深化成堅不可摧的記憶唷。\n(圖片來源: 淺談記憶法（二）遺忘曲線與艾賓浩斯記憶法 - SoLeisure)\n至於間隔的時間，有很多種說法。我自己使用的是1天→2天→1周→1個月。不過由於準備學測時的大量刷題本身就是一種複習與記憶提取，所以我當時是沒有去使用這個方法，只有在背單字時使用(可以參考我等等會提到的背單字法)。\n還有一些軟體有提供間隔複習的功能，例如Anki、Quizlet等等，有些人會使用這些軟體背單字，但我覺得用這個背單字效率不夠高，光是輸入就要花很多時間，但如果你原本就使用電腦學習(例如讀課本的pdf、或要記憶網路上的內容等等，這通常大學以後才比較需要)，用這些軟體的效率就會提高許多。\n我所使用的講義\r數學: 徐式分冊 物理、化學、生物、地科: 新關鍵 國文: 大滿貫、大講堂文言文15篇 很多人推薦搶救國文大作戰，但我其實不推，裡面的編排方式相較於大滿貫更不易閱讀，而且有許多瑣碎且學測不會考的知識，如果對國文沒興趣只是想應付學測的話，讀大滿貫就好了。 英文: Kuso 酷文法 地理、歷史、公民: 大滿貫 各科的一些小Tips\r數學\r這裡推薦一本書—George Polya的\u0026laquo;怎樣解題\u0026raquo;，裡面有教了許多種解題的方法，讀完之後數學能力應該會有所提升。 寫題目時抱持著「每一題一定有解」的觀念，將題目給你的線索「全部」列出來(這很重要)，再看看你可以用這些線索推敲出甚麼結果(這也很重要)，因為最終的答案一定可以靠題目給你的線索解答出來。 如果看著題目給你的線索卻還沒有頭緒，可以看答案要你求甚麼，接著在反推要怎麼樣才能求得答案所需要的條件，就這樣一步步反推，推至你已經知道的條件，如此一來就可以透過逆推法來解題。 自然\r物理、化學需要計算的部分，就用跟數學解題時類似的方式，來求得答案。相信經過選修物理、化學磨練過的大家，對於學測範圍的計算部分相當的得心應手。 其他需要記憶的部分，就透過前面提到的Active Recall法來解決。 英文\r學習一個語言最重要的是培養「語感」，而培養語感的方法就是盡量多接觸這個語言。平常可以多看一些英文影片、小說、文章之類的。小說的話我推薦Tess Gerritsen的懸疑推理小說，真的很好看.w.，不過字數有點多，一開始可以先挑字數少一點的小說看。 英文基本上把單字、片語、文法背熟就可以全對了。至於要如何有效率的背單字可以參考我之前學習歷程做的 兩個月記牢一萬五千單字.pdf\n國文\r國綜 國學常識 把古文15篇中出現的字詞解釋與讀音背熟，並熟悉他們的相近字。接著再把其他國學常識背熟即可 閱讀理解、混合題: 寫的時候先看題目問你甚麼，如此一來在閱讀時才能夠有比較清楚的方向，也更能夠記住重要的內容。 研究顯示，在閱讀時用手指或筆追蹤你所讀到的內容，可以有效提高閱讀速度以及理解力。 如果平常寫閱讀測驗正確率沒辦法達到8成的話，可以每天練習寫\u0026laquo;古今悅讀100\u0026raquo;，並找出自己錯誤的原因，等到正確率有個8、9成(扣掉粗心錯的)以後，大概1~2個禮拜寫一次閱讀測驗維持手感就好了喔。 國寫 基本上就是常看學測歷年佳作、作文比賽得獎作品或是對岸的高考滿分作文，試著內化他們所表達的東西，接著再用自己的話表達一次，看看自己寫的跟他們寫的有哪裡不同，並找出可以改進的地方。 多多練習是關鍵，可以的話盡量請老師改自己練習寫的內容，並找出不足的地方加以改進。 在開始寫之前先想好結尾會是甚麼，接著通篇保持最後的立場，不要在多個觀點間猶豫不定。拿高分的首要重點是看你能不能清楚有條理的表達自己的想法，其次才是詞藻的優美度。 社會\r基本上使用Active Recall搭配大量刷題，就可以15了喔 時間管理\r我平常會使用上課時間來自習，這樣就等於一天多了5小時左右的自習時間(扣掉一些不能自習的課)，而且這樣回家就不用讀書了。 休息很重要，不要整天都在讀書，適當休息的學習成效會比整天都在讀書要好很多。 第二階段: 刷題\r將每科的講義大概看完後，刷題就是接下來最重要的關鍵。透過大量且有效的刷題，考試時才能更加得心應手，也是區分頂標跟15級的關鍵。\n快速刷題技巧\r對於理科而言，如果你已經知道接下來怎麼算，就沒必要把整題都算完，可以直接跳下一題。如此一來，你在刷題時就會發現有很多題是一眼就知道可以直接跳過的，沒必要花費多餘的時間，至於有些比較算法不明顯的題目，只需要把式子列至你知道接下來怎麼算即可。用這個方法，大約15~30分鐘就可以刷完一張自然模擬考考卷、20~40分鐘就可以刷完一張數學考卷喔。 對於背科而言，如果題目考的是你很熟悉的範圍，那就可以直接跳過。如果你對閱讀測驗也很有把握，那也可以直接跳過。不過遇到那種題幹稍長的題目，還是建議看清楚他要問甚麼比較好。 錯題本\r顧名思義就是把寫錯的題目記錄在一個本子上，之後再重複複習。這裡可以用拍照代替，之後也比較方便把照片放到間隔複習的軟體(如Anki)上，比手抄省下很多時間。這個方法我到2023年5月才開始使用，所以準備學測時沒有用到，不過我覺得這是一個很有用的方法。\n刷題的意義\r刷題時也可以想想，和這題有關的其他知識，我是不是都記清楚了，而不是只專注在眼前題目問你的東西，不要只為了答對眼前的題目而刷題，你這題是錯是對都不是重點，重點是你從刷題的過程中學習到了甚麼，並要怎麼應用在正式考試上。 第三階段: 應試\r過程\r如果你知道眼前的題目會花你很多時間，那就先跳過去寫後面的題目，不要因為在這題卡太久而導致後面該拿的分數沒拿，並在跳題的保持平靜的心態，不要因此慌了手腳，畢竟如果這道題真的很麻煩，那大家也很可能會答錯。(但記得最後要回來寫!!!) 寫數學的順序: 單選→填充→混合→多選，因為多選通常最麻煩，放最後比較不會心態崩，至於填充跟混合的順序可以調換，如果混合很簡單的話。 一些偷吃步小技巧\r注意: 以下方法只適用於學測 / 指考等大考中心的考試，對模擬考沒有用。\n領域展開法\r以112數A單選最後一題為例\n嗯，這題一看就是很麻煩的窮舉，如果要算的話可能需要花3~5分鐘，不過當時我用了一招，5秒鐘就知道答案ㄌ。先來看看我當時的視角。\n有沒有發現，已經到了單選最後一題，卻還沒有出現過3，所以這題答案就是3(ㄏㄏ)。\n這是大考中心的命題規則，如果題目數比選項數多的話，每個選項一定會出現至少一次，我檢查了近五年的答案皆是如此。所以如果你已經寫到單選的最後一題，卻還沒出現過某個選項，那最後一題的答案9成以上就是那個選項。檢查的時候甚至不用檢查最後一題，檢查前面就好了。(不過用這個方法的時候，要確定前面都有寫對)\n如果是分科數甲的話，由於單選只有3題，所以一定不會有重複的答案，這是大考中心為了避免有人靠猜題得到較高的分數的應對措施，不過我們正好可以用這個規則來猜答案.w.。\n多選判斷法\r分科 / 指考的多選，答案不是2個選項就是3個選項(數甲是2個選項居多)，不信的話可以去大考中心官網上確認。因此，可以透過這招來加速寫題的過程，或是刪掉不確定的答案。 其他一些推薦影片\r不會寫的題目也能90%猜對的方法？ 世界冠軍：用考試讀心術 ｜ 考試讀心術 第一集\n如何快速提高考試分數？ ​ 多選題猜答案的最優數學策略\n補充: 5本有助於學習的書\r以下是我讀過，對我學習方式影響最大的5本書，在這邊推薦給大家\n大腦什麼都記得住\r這本書是由美國記憶比賽冠軍所寫，裡面介紹了許多記憶的方法，內容非常實用。\n大腦什麼都記得住！用更少的力氣記住更多的東西，四屆記憶冠軍親授的「超效率無極限記憶術」\n超速學習\r這本書對於要怎麼快速且系統性的學習一個領域提供了相當詳細的教學，如果想要學習新事物，這會是一本很有用的書籍。\n超速學習：我這樣做，一個月學會素描，一年學會四種語言，完成MIT四年課程\n大腦喜歡這樣學\r這本書把許多高效率的讀書方法大致都講過了，如果你看完這篇文章後對學習技巧感到興趣，那我建議你可以來讀這本書喔\n大腦喜歡這樣學：先認識自己的大腦，找到正確的思考路徑，就能專注、不拖延，提高記憶力，學會如何學習(二版)\n怎樣解題\r這本書以許多的面向，講述了各種解題的策略與技巧。如果你想要增強自己的解題能力，這本書應該會有所幫助。\n怎樣解題\n刻意練習\r這本書詳細的講述了要在一個領域變成專家，比起天賦更重要的是訓練的方式。透過這本書教的練習方式，你也可以達成原先所認為不可能的事，取得驚人的成就喔。\n刻意練習：原創者全面解析，比天賦更關鍵的學習法\n後記\r每個人適合的讀書方法不盡相同，如果你覺得我的讀書方法對你沒什麼用，那也可以試著找找看對自己最有效的讀書方式喔。那就祝各位學弟妹考試順利，學測就上!\n還有對於某些科系而言，二階才是重點，大家記得好好準備二階考古題或是口試喔~\n","date":"2023-10-15T00:00:00Z","image":"http://localhost:1313/p/%E5%AD%B8%E6%B8%AC%E8%AE%80%E6%9B%B8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/b_hu7404989912241337256.jpg","permalink":"http://localhost:1313/p/%E5%AD%B8%E6%B8%AC%E8%AE%80%E6%9B%B8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/","title":"學測讀書技巧分享"}]